<xml xmlns="https://developers.google.com/blockly/xml"><block type="pxt-on-start" id="l1Pz/qeR+[^r3c1EZ}}x" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="?Q/9uB1?QYa=iYcBq963" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace maqueenSimple {" line1="" line2="    // weight=100 color=#0fbc11 icon=&quot;\uf067&quot; block=&quot;maqueenPlusV2&quot;" line3="" line4="    //Motor selection enumeration" line5="    export enum Motor {" line6="        //% block=&quot;left motor&quot;" line7="        LeftMotor," line8="        //% block=&quot;right motor&quot;" line9="        RightMotor," line10="        //% block=&quot;both motors&quot;" line11="        AllMotor," line12="    };" line13="" line14="    //Motor direction enumeration selection" line15="    export enum Dir {" line16="        //% block=&quot;forwards&quot;" line17="        Forward," line18="        //% block=&quot;backwards&quot;" line19="        Backward," line20="    };" line21="" line22="    //LED light selection enumeration" line23="    export enum MyEnumLed {" line24="        //% block=&quot;left LED light&quot;" line25="        LeftLed," line26="        //% block=&quot;right LED light&quot;" line27="        RightLed," line28="        //% block=&quot;all LED light&quot;" line29="        AllLed," line30="    };" line31="" line32="    //LED light switch enumeration selection" line33="    export enum MyEnumSwitch {" line34="        //% block=&quot;off&quot;" line35="        Close," line36="        //% block=&quot;on&quot;" line37="        Open," line38="    };" line39="" line40="    //Line sensor selection" line41="    export enum MyEnumLineSensor {" line42="        //% block=&quot;L1&quot;" line43="        SensorL1," line44="        //% block=&quot;M&quot;" line45="        SensorM," line46="        //% block=&quot;R1&quot;" line47="        SensorR1," line48="        //% block=&quot;L2&quot;" line49="        SensorL2," line50="        //% block=&quot;R2&quot;" line51="        SensorR2," line52="    };" line53="    /**" line54="     * Well known colors for a NeoPixel strip" line55="     */" line56="    export enum NeoPixelColors {" line57="        //% block=red" line58="        Red = 0xFF0000," line59="        //% block=orange" line60="        Orange = 0xFF6C00," line61="        //% block=yellow" line62="        Yellow = 0xFFFF00," line63="        //% block=green" line64="        Green = 0x00FF00," line65="        //% block=blue" line66="        Blue = 0x0000FF," line67="        //% block=indigo" line68="        Indigo = 0x4b0082," line69="        //% block=violet" line70="        Violet = 0x8a2be2," line71="        //% block=purple" line72="        Purple = 0xFF00FF," line73="        //% block=white" line74="        White = 0xFFFFFF," line75="        //% block=black" line76="        Black = 0x000000" line77="    }" line78="" line79="    export enum LeftRight {" line80="        //% block=&quot;↺ left&quot;" line81="        Left," line82="        //% block=&quot;↻ right&quot;" line83="        Right" line84="    }" line85="" line86="    export enum NeoPixelEnum {" line87="        //% block=&quot;all&quot;" line88="        All," line89="        //% block=&quot;front left&quot;" line90="        FrontLeft," line91="        //% block=&quot;front right&quot;" line92="        FrontRight," line93="        //% block=&quot;back left&quot;" line94="        BackLeft," line95="        //% block=&quot;back right&quot;" line96="        BackRight" line97="    }" line98="" line99="    const I2CADDR = 0x10;" line100="    const ADC0_REGISTER = 0X1E;" line101="    const ADC1_REGISTER = 0X20;" line102="    const ADC2_REGISTER = 0X22;" line103="    const ADC3_REGISTER = 0X24;" line104="    const ADC4_REGISTER = 0X26;" line105="    const LEFT_LED_REGISTER = 0X0B;" line106="    const RIGHT_LED_REGISTER = 0X0C;" line107="    const LEFT_MOTOR_REGISTER = 0X00;" line108="    const RIGHT_MOTOR_REGISTER = 0X02;" line109="    const LINE_STATE_REGISTER = 0X1D;" line110="    const VERSION_CNT_REGISTER = 0X32;" line111="    const VERSION_DATA_REGISTER = 0X33;" line112="" line113="    let irstate: number;" line114="    let neopixel_buf = pins.createBuffer(16 * 3);" line115="    for (let i = 0; i &lt; 16 * 3; i++) {" line116="        neopixel_buf[i] = 0" line117="    }" line118="    let _brightness = 255" line119="    let state: number;" line120="" line121="    /**" line122="     *  Init I2C until success" line123="     */" line124="" line125="    //% weight=0" line126="    //%block=&quot;initialize robot&quot;" line127="    export function I2CInit(): void {" line128="        let Version_v = 0;" line129="        pins.i2cWriteNumber(I2CADDR, 0x32, NumberFormat.Int8LE);" line130="        Version_v = pins.i2cReadNumber(I2CADDR, NumberFormat.Int8LE);" line131="        while (Version_v == 0) {" line132="            basic.showLeds(`" line133="                # . . . #" line134="                . # . # ." line135="                . . # . ." line136="                . # . # ." line137="                # . . . #" line138="                `, 10)" line139="            basic.pause(500)" line140="            basic.clearScreen()" line141="            pins.i2cWriteNumber(0x10, 0x32, NumberFormat.Int8LE);" line142="            Version_v = pins.i2cReadNumber(I2CADDR, NumberFormat.Int8LE);" line143="        }" line144="        basic.showLeds(`" line145="                . . . . ." line146="                . . . . #" line147="                . . . # ." line148="                # . # . ." line149="                . # . . ." line150="                `, 10)" line151="        basic.pause(500)" line152="        basic.clearScreen()" line153="    }" line154="" line155="    /**" line156="     * Move forward for a certain amount of time." line157="     * @param edir Direction to move in" line158="     * @param time How long to move forward for" line159="     */" line160="" line161="    //% block=&quot;move %edir for %time seconds&quot;" line162="    //% time.min=0 time.max=100" line163="    //% weight=100" line164="    export function moveForward(edir: Dir, time: number): void {" line165="        controlMotor(Motor.AllMotor, edir, 100);" line166="        basic.pause(time * 1000);" line167="        controlMotorStop(Motor.AllMotor);" line168="    }" line169="" line170="" line171="    /**" line172="     * Turn in a direction for a certain amount of time." line173="     * @param dir Direction to move in" line174="     * @param time How long to turn for" line175="     */" line176="    //% block=&quot;turn %dir for %time seconds&quot;" line177="    //% time.min=0 time.max=10" line178="    //% weight=99" line179="    export function turn(dir: LeftRight, time: number): void {" line180="        if (dir == LeftRight.Left) {" line181="            controlMotor(Motor.LeftMotor, Dir.Backward, 100);" line182="            controlMotor(Motor.RightMotor, Dir.Forward, 100);" line183="        } else if (dir == LeftRight.Right) {" line184="            controlMotor(Motor.RightMotor, Dir.Backward, 100);" line185="            controlMotor(Motor.LeftMotor, Dir.Forward, 100);" line186="        }" line187="        basic.pause(time * 1000);" line188="        controlMotorStop(Motor.AllMotor);" line189="    }" line190="" line191="    // /**" line192="    //  * Stop all motors." line193="    //  */" line194="    // //% block=&quot;stop&quot;" line195="    // export function stop(): void {" line196="    //     let allBuffer2 = pins.createBuffer(5);" line197="    //     allBuffer2[0] = LEFT_MOTOR_REGISTER;" line198="    //     allBuffer2[1] = 0;" line199="    //     allBuffer2[2] = 0;" line200="    //     allBuffer2[3] = 0;" line201="    //     allBuffer2[4] = 0;" line202="    //     pins.i2cWriteBuffer(I2CADDR, allBuffer2);" line203="    // }" line204="" line205="    /**" line206="     * Set motor to a speed" line207="     * @param emotor Motor selection " line208="     * @param edir   Motor direction" line209="     * @param speed  Motor speed control (0-255)" line210="     */" line211="" line212="    //% block=&quot;set %emotor moving %edir speed %speed&quot;" line213="    //% speed.min=0 speed.max=255" line214="    //% weight=98" line215="    export function controlMotor(emotor: Motor, edir: Dir, speed: number): void {" line216="        switch (emotor) {" line217="            case Motor.LeftMotor:" line218="                let leftBuffer = pins.createBuffer(3);" line219="                leftBuffer[0] = LEFT_MOTOR_REGISTER;" line220="                leftBuffer[1] = edir;" line221="                leftBuffer[2] = speed;" line222="                pins.i2cWriteBuffer(I2CADDR, leftBuffer);" line223="                break;" line224="            case Motor.RightMotor:" line225="                let rightBuffer = pins.createBuffer(3);" line226="                rightBuffer[0] = RIGHT_MOTOR_REGISTER;" line227="                rightBuffer[1] = edir;" line228="                rightBuffer[2] = speed;" line229="                pins.i2cWriteBuffer(I2CADDR, rightBuffer);" line230="                break;" line231="            default:" line232="                let allBuffer = pins.createBuffer(5);" line233="                allBuffer[0] = LEFT_MOTOR_REGISTER;" line234="                allBuffer[1] = edir;" line235="                allBuffer[2] = speed;" line236="                allBuffer[3] = edir;" line237="                allBuffer[4] = speed;" line238="                pins.i2cWriteBuffer(I2CADDR, allBuffer)" line239="                break;" line240="        }" line241="    }" line242="" line243="    /**" line244="     * Set motor to a speed" line245="     * @param emotor Motor selection" line246="     * @param speed  Motor speed control (-255 to 255)" line247="     */" line248="" line249="    //% block=&quot;set %emotor speed %speed&quot;" line250="    //% speed.min=-255 speed.max=255" line251="    //% weight=98" line252="    export function controlMotor2(emotor: Motor, speed: number): void {" line253="        if (speed &lt; 0) {" line254="            controlMotor(emotor, Dir.Backward, Math.abs(speed));" line255="        } else {" line256="            controlMotor(emotor, Dir.Forward, speed);" line257="        }" line258="    }" line259="" line260="    /**" line261="     * Control the motor module to stop running" line262="     * @param emotor Motor selection enumeration" line263="     */" line264="" line265="    //% block=&quot;stop %emotor&quot;" line266="    //% weight=98" line267="    export function controlMotorStop(emotor: Motor): void {" line268="        switch (emotor) {" line269="            case Motor.LeftMotor:" line270="                let leftBuffer2 = pins.createBuffer(3);" line271="                leftBuffer2[0] = LEFT_MOTOR_REGISTER;" line272="                leftBuffer2[1] = 0;" line273="                leftBuffer2[2] = 0;" line274="                pins.i2cWriteBuffer(I2CADDR, leftBuffer2);" line275="                break;" line276="            case Motor.RightMotor:" line277="                let rightBuffer2 = pins.createBuffer(3);" line278="                rightBuffer2[0] = RIGHT_MOTOR_REGISTER;" line279="                rightBuffer2[1] = 0;" line280="                rightBuffer2[2] = 0;" line281="                pins.i2cWriteBuffer(I2CADDR, rightBuffer2);" line282="                break;" line283="            default:" line284="                let allBuffer22 = pins.createBuffer(5);" line285="                allBuffer22[0] = LEFT_MOTOR_REGISTER;" line286="                allBuffer22[1] = 0;" line287="                allBuffer22[2] = 0;" line288="                allBuffer22[3] = 0;" line289="                allBuffer22[4] = 0;" line290="                pins.i2cWriteBuffer(I2CADDR, allBuffer22)" line291="                break;" line292="        }" line293="    }" line294="" line295="    /**" line296="     * Control left and right LED light switch module" line297="     * @param eled LED lamp selection" line298="     * @param eSwitch Control LED light on or off" line299="     */" line300="" line301="    //% block=&quot;turn %eled %eSwitch&quot;" line302="    //% weight=97" line303="    export function controlLED(eled: MyEnumLed, eSwitch: MyEnumSwitch): void {" line304="        switch (eled) {" line305="            case MyEnumLed.LeftLed:" line306="                let leftLedControlBuffer = pins.createBuffer(2);" line307="                leftLedControlBuffer[0] = LEFT_LED_REGISTER;" line308="                leftLedControlBuffer[1] = eSwitch;" line309="                pins.i2cWriteBuffer(I2CADDR, leftLedControlBuffer);" line310="                break;" line311="            case MyEnumLed.RightLed:" line312="                let rightLedControlBuffer = pins.createBuffer(2);" line313="                rightLedControlBuffer[0] = RIGHT_LED_REGISTER;" line314="                rightLedControlBuffer[1] = eSwitch;" line315="                pins.i2cWriteBuffer(I2CADDR, rightLedControlBuffer);" line316="                break;" line317="            default:" line318="                let allLedControlBuffer = pins.createBuffer(3);" line319="                allLedControlBuffer[0] = LEFT_LED_REGISTER;" line320="                allLedControlBuffer[1] = eSwitch;" line321="                allLedControlBuffer[2] = eSwitch;" line322="                pins.i2cWriteBuffer(I2CADDR, allLedControlBuffer);" line323="                break;" line324="        }" line325="    }" line326="" line327="    /**" line328="     * Get the state of the patrol sensor" line329="     * @param eline Select the inspection sensor enumeration" line330="     */" line331="" line332="    //% block=&quot;read line sensor %eline state&quot;" line333="    //% weight=96" line334="    export function readLineSensorState(eline: MyEnumLineSensor): number {" line335="        pins.i2cWriteNumber(I2CADDR, LINE_STATE_REGISTER, NumberFormat.Int8LE);" line336="        let data = pins.i2cReadNumber(I2CADDR, NumberFormat.Int8LE)" line337="        let state2;" line338="        switch (eline) {" line339="            case MyEnumLineSensor.SensorL1:" line340="                state2 = (data &amp; 0x08) == 0x08 ? 1 : 0;" line341="                break;" line342="            case MyEnumLineSensor.SensorM:" line343="                state2 = (data &amp; 0x04) == 0x04 ? 1 : 0;" line344="                break;" line345="            case MyEnumLineSensor.SensorR1:" line346="                state2 = (data &amp; 0x02) == 0x02 ? 1 : 0;" line347="                break;" line348="            case MyEnumLineSensor.SensorL2:" line349="                state2 = (data &amp; 0x10) == 0X10 ? 1 : 0;" line350="                break;" line351="            default:" line352="                state2 = (data &amp; 0x01) == 0x01 ? 1 : 0;" line353="                break;" line354="        }" line355="        return state2;" line356="    }" line357="" line358="    /**" line359="     * The ADC data of the patrol sensor is obtained" line360="     * @param eline Select the inspection sensor enumeration" line361="     */" line362="" line363="    //% block=&quot;read line sensor %eline  ADC data&quot;" line364="    //% weight=95" line365="    // export function readLineSensorData(eline: MyEnumLineSensor): number {" line366="    //     let data2;" line367="    //     switch (eline) {" line368="    //         case MyEnumLineSensor.SensorR2:" line369="    //             pins.i2cWriteNumber(I2CADDR, ADC0_REGISTER, NumberFormat.Int8LE);" line370="    //             let adc0Buffer = pins.i2cReadBuffer(I2CADDR, 1);" line371="    //             data2 = adc0Buffer[1] &lt;&lt; 8 | adc0Buffer[0]" line372="    //             break;" line373="    //         case MyEnumLineSensor.SensorR1:" line374="    //             pins.i2cWriteNumber(I2CADDR, ADC1_REGISTER, NumberFormat.Int8LE);" line375="    //             let adc1Buffer = pins.i2cReadBuffer(I2CADDR, 2);" line376="    //             data2 = adc1Buffer[1] &lt;&lt; 8 | adc1Buffer[0];" line377="    //             break;" line378="    //         case MyEnumLineSensor.SensorM:" line379="    //             pins.i2cWriteNumber(I2CADDR, ADC2_REGISTER, NumberFormat.Int8LE);" line380="    //             let adc2Buffer = pins.i2cReadBuffer(I2CADDR, 2);" line381="    //             data2 = adc2Buffer[1] &lt;&lt; 8 | adc2Buffer[0];" line382="    //             break;" line383="    //         case MyEnumLineSensor.SensorL1:" line384="    //             pins.i2cWriteNumber(I2CADDR, ADC3_REGISTER, NumberFormat.Int8LE);" line385="    //             let adc3Buffer = pins.i2cReadBuffer(I2CADDR, 2);" line386="    //             data2 = adc3Buffer[1] &lt;&lt; 1 | adc3Buffer[0];" line387="    //             break;" line388="    //         default:" line389="    //             pins.i2cWriteNumber(I2CADDR, ADC4_REGISTER, NumberFormat.Int8LE);" line390="    //             let adc4Buffer = pins.i2cReadBuffer(I2CADDR, 2);" line391="    //             data2 = adc4Buffer[1] &lt;&lt; 8 | adc4Buffer[0];" line392="    //             break;" line393="" line394="    //     }" line395="    //     return data2;" line396="    // }" line397="" line398="    /**" line399="     * Acquiring ultrasonic data better" line400="     */" line401="" line402="    //% block=&quot;read ultrasonic distance (cm)&quot;" line403="    //% weight=94" line404="    export function readDistance(): number {" line405="        let trig=DigitalPin.P13;" line406="        let echo=DigitalPin.P14;" line407="        let data3;" line408="        pins.digitalWritePin(trig, 1);" line409="        basic.pause(1);" line410="        pins.digitalWritePin(trig, 0)" line411="        if (pins.digitalReadPin(echo) == 0) {" line412="            pins.digitalWritePin(trig, 0);" line413="            pins.digitalWritePin(trig, 1);" line414="            basic.pause(20);" line415="            pins.digitalWritePin(trig, 0);" line416="            data3 = pins.pulseIn(echo, PulseValue.High, 500 * 58);" line417="        } else {" line418="            pins.digitalWritePin(trig, 1);" line419="            pins.digitalWritePin(trig, 0);" line420="            basic.pause(20);" line421="            pins.digitalWritePin(trig, 0);" line422="            data3 = pins.pulseIn(echo, PulseValue.High, 500 * 58)" line423="        }" line424="        data3 = data3 / 59;" line425="        if (data3 &lt;= 0)" line426="            return 0;" line427="        if (data3 &gt; 500)" line428="            return 500;" line429="        return Math.round(data3);" line430="    }" line431="" line432="    // /**" line433="    //  * Acquiring ultrasonic data" line434="    //  * @param trig trig pin selection enumeration, eg:DigitalPin.P13" line435="    //  * @param echo echo pin selection enumeration, eg:DigitalPin.P14" line436="    //  */" line437="" line438="    // //% block=&quot;set ultrasonic sensor TRIG pin %trig ECHO pin %echo read data unit:cm&quot;" line439="    // //% weight=94" line440="    // export function readUltrasonic(trig: DigitalPin, echo: DigitalPin): number {" line441="    //     let data32;" line442="    //     pins.digitalWritePin(trig, 1);" line443="    //     basic.pause(1);" line444="    //     pins.digitalWritePin(trig, 0)" line445="    //     if (pins.digitalReadPin(echo) == 0) {" line446="    //         pins.digitalWritePin(trig, 0);" line447="    //         pins.digitalWritePin(trig, 1);" line448="    //         basic.pause(20);" line449="    //         pins.digitalWritePin(trig, 0);" line450="    //         data32 = pins.pulseIn(echo, PulseValue.High, 500 * 58);" line451="    //     } else {" line452="    //         pins.digitalWritePin(trig, 1);" line453="    //         pins.digitalWritePin(trig, 0);" line454="    //         basic.pause(20);" line455="    //         pins.digitalWritePin(trig, 0);" line456="    //         data32 = pins.pulseIn(echo, PulseValue.High, 500 * 58)" line457="    //     }" line458="    //     data32 = data32 / 59;" line459="    //     if (data32 &lt;= 0)" line460="    //         return 0;" line461="    //     if (data32 &gt; 500)" line462="    //         return 500;" line463="    //     return Math.round(data32);" line464="    // }" line465="" line466="    // /**" line467="    //  * Getting the version number" line468="    //  */" line469="" line470="    // //% block=&quot;read version&quot;" line471="    // //% weight=2" line472="    // //% advanced=true" line473="    // export function readVersion(): string {" line474="    //     let version;" line475="    //     pins.i2cWriteNumber(I2CADDR, VERSION_CNT_REGISTER, NumberFormat.Int8LE);" line476="    //     version = pins.i2cReadNumber(I2CADDR, NumberFormat.Int8LE);" line477="    //     pins.i2cWriteNumber(I2CADDR, VERSION_DATA_REGISTER, NumberFormat.Int8LE);" line478="    //     version = pins.i2cReadBuffer(I2CADDR, version);" line479="    //     let versionString = version.toString();" line480="    //     return versionString" line481="    // }" line482="" line483="" line484="" line485="    /** " line486="    * Set the three primary color:red, green, and blue" line487="    * @param r  , eg: 100" line488="    * @param g  , eg: 100" line489="    * @param b  , eg: 100" line490="    */" line491="" line492="    //% weight=60" line493="    //% r.min=0 r.max=255" line494="    //% g.min=0 g.max=255" line495="    //% b.min=0 b.max=255" line496="    //% block=&quot;red|%r green|%g blue|%b&quot;" line497="    export function rgb(r: number, g: number, b: number): number {" line498="        return (r &lt;&lt; 16) + (g &lt;&lt; 8) + (b);" line499="    }" line500="" line501="    // /**" line502="    //  * The LED positions where you wish to begin and end" line503="    //  * @param from  , eg: 1" line504="    //  * @param to  , eg: 4" line505="    //  */" line506="" line507="    // //% weight=60" line508="    // //% from.min=0 from.max=3" line509="    // //% to.min=1 to.max=4" line510="    // //% block=&quot;range from |%from with|%to leds&quot;" line511="    // export function ledRange(from: number, to: number): number {" line512="    //     return ((from) &lt;&lt; 16) + (2 &lt;&lt; 8) + (to);" line513="    // }" line514="" line515="    /**" line516="     * Set the color of the specified LEDs" line517="     * @param index  , eg: 1" line518="     */" line519="" line520="    //% weight=60" line521="    //% index.min=0 index.max=3" line522="    //% block=&quot;show color |%rgb on |%light RGB light&quot;" line523="    export function setIndexColor(rgb: NeoPixelColors, light: NeoPixelEnum) {" line524="        let index = 0;" line525="        if (light == NeoPixelEnum.All) {" line526="            showColor(rgb);" line527="            return;" line528="        } else {" line529="            switch (light) {" line530="                case NeoPixelEnum.FrontLeft: index = 0; break;" line531="                case NeoPixelEnum.BackLeft: index = 1; break;" line532="                case NeoPixelEnum.BackRight: index = 2; break;" line533="                case NeoPixelEnum.FrontRight: index = 3; break;" line534="            }" line535="        }" line536="" line537="        let f = index;" line538="        let t = index;" line539="        let r = (rgb &gt;&gt; 16) * (_brightness / 255);" line540="        let g = ((rgb &gt;&gt; 8) &amp; 0xFF) * (_brightness / 255);" line541="        let b = ((rgb) &amp; 0xFF) * (_brightness / 255);" line542="" line543="        if (index &gt; 15) {" line544="            if (((index &gt;&gt; 8) &amp; 0xFF) == 0x02) {" line545="                f = index &gt;&gt; 16;" line546="                t = index &amp; 0xff;" line547="            } else {" line548="                f = 0;" line549="                t = -1;" line550="            }" line551="        }" line552="        for (let j = f; j &lt;= t; j++) {" line553="            neopixel_buf[j * 3 + 0] = Math.round(g)" line554="            neopixel_buf[j * 3 + 1] = Math.round(r)" line555="            neopixel_buf[j * 3 + 2] = Math.round(b)" line556="        }" line557="        ws2812b.sendBuffer(neopixel_buf, DigitalPin.P15)" line558="" line559="    }" line560="" line561="    /**" line562="     * Set the color of all RGB LEDs" line563="     */" line564="" line565="    export function showColor(rgb: NeoPixelColors) {" line566="        let s = (rgb &gt;&gt; 16) * (_brightness / 255);" line567="        let h = ((rgb &gt;&gt; 8) &amp; 0xFF) * (_brightness / 255);" line568="        let c = ((rgb) &amp; 0xFF) * (_brightness / 255);" line569="        for (let k = 0; k &lt; 16 * 3; k++) {" line570="            if ((k % 3) == 0)" line571="                neopixel_buf[k] = Math.round(h)" line572="            if ((k % 3) == 1)" line573="                neopixel_buf[k] = Math.round(s)" line574="            if ((k % 3) == 2)" line575="                neopixel_buf[k] = Math.round(c)" line576="        }" line577="        ws2812b.sendBuffer(neopixel_buf, DigitalPin.P15)" line578="    }" line579="" line580="    /**" line581="     * Set the brightness of RGB LED" line582="     * @param brightness  , eg: 100" line583="     */" line584="" line585="    //% weight=70" line586="    //% brightness.min=0 brightness.max=255" line587="    //% block=&quot;set RGB brightness to |%brightness&quot;" line588="    export function setBrightness(brightness: number) {" line589="        _brightness = brightness;" line590="    }" line591="" line592="    /**" line593="     * Turn off all RGB LEDs" line594="     */" line595="" line596="    //% weight=40" line597="    //% block=&quot;clear all RGB&quot;" line598="    export function ledBlank() {" line599="        showColor(0)" line600="    }" line601="" line602="    // /**" line603="    //  * RGB LEDs display rainbow colors " line604="    //  */" line605="" line606="    // //% weight=50" line607="    // //% startHue.defl=1" line608="    // //% endHue.defl=360" line609="    // //% startHue.min=0 startHue.max=360" line610="    // //% endHue.min=0 endHue.max=360" line611="    // export function ledRainbow(startHue: number, endHue: number) {" line612="    //     startHue = startHue &gt;&gt; 0;" line613="    //     endHue = endHue &gt;&gt; 0;" line614="    //     const saturation = 100;" line615="    //     const luminance = 50;" line616="    //     let steps = 3 + 1;" line617="    //     const direction = HueInterpolationDirection.Clockwise;" line618="" line619="    //     //hue" line620="    //     const h1 = startHue;" line621="    //     const h2 = endHue;" line622="    //     const hDistCW = ((h2 + 360) - h1) % 360;" line623="    //     const hStepCW = Math.idiv((hDistCW * 100), steps);" line624="    //     const hDistCCW = ((h1 + 360) - h2) % 360;" line625="    //     const hStepCCW = Math.idiv(-(hDistCCW * 100), steps);" line626="    //     let hStep: number;" line627="    //     if (direction === HueInterpolationDirection.Clockwise) {" line628="    //         hStep = hStepCW;" line629="    //     } else if (direction === HueInterpolationDirection.CounterClockwise) {" line630="    //         hStep = hStepCCW;" line631="    //     } else {" line632="    //         hStep = hDistCW &lt; hDistCCW ? hStepCW : hStepCCW;" line633="    //     }" line634="    //     const h1_100 = h1 * 100; //we multiply by 100 so we keep more accurate results while doing interpolation" line635="" line636="    //     //sat" line637="    //     const s1 = saturation;" line638="    //     const s2 = saturation;" line639="    //     const sDist = s2 - s1;" line640="    //     const sStep = Math.idiv(sDist, steps);" line641="    //     const s1_100 = s1 * 100;" line642="" line643="    //     //lum" line644="    //     const l1 = luminance;" line645="    //     const l2 = luminance;" line646="    //     const lDist = l2 - l1;" line647="    //     const lStep = Math.idiv(lDist, steps);" line648="    //     const l1_100 = l1 * 100" line649="" line650="    //     //interpolate" line651="    //     if (steps === 1) {" line652="    //         writeBuff(0, hsl(h1 + hStep, s1 + sStep, l1 + lStep))" line653="    //     } else {" line654="    //         writeBuff(0, hsl(startHue, saturation, luminance));" line655="    //         for (let l = 1; l &lt; steps - 1; l++) {" line656="    //             const m = Math.idiv((h1_100 + l * hStep), 100) + 360;" line657="    //             const u = Math.idiv((s1_100 + l * sStep), 100);" line658="    //             const n = Math.idiv((l1_100 + l * lStep), 100);" line659="    //             writeBuff(0 + l, hsl(m, u, n));" line660="    //         }" line661="    //         writeBuff(3, hsl(endHue, saturation, luminance));" line662="    //     }" line663="    //     ws2812b.sendBuffer(neopixel_buf, DigitalPin.P15)" line664="    // }" line665="" line666="    export enum HueInterpolationDirection {" line667="        Clockwise," line668="        CounterClockwise," line669="        Shortest" line670="    }" line671="" line672="    function writeBuff(index: number, rgb: number) {" line673="        let v = (rgb &gt;&gt; 16) * (_brightness / 255);" line674="        let o = ((rgb &gt;&gt; 8) &amp; 0xFF) * (_brightness / 255);" line675="        let d = ((rgb) &amp; 0xFF) * (_brightness / 255);" line676="        neopixel_buf[index * 3 + 0] = Math.round(o)" line677="        neopixel_buf[index * 3 + 1] = Math.round(v)" line678="        neopixel_buf[index * 3 + 2] = Math.round(d)" line679="    }" line680="" line681="    function hsl(h: number, s: number, l: number): number {" line682="        h = Math.round(h);" line683="        s = Math.round(s);" line684="        l = Math.round(l);" line685="" line686="        h = h % 360;" line687="        s = Math.clamp(0, 99, s);" line688="        l = Math.clamp(0, 99, l);" line689="        let e = Math.idiv((((100 - Math.abs(2 * l - 100)) * s) &lt;&lt; 8), 10000); //chroma, [0,255]" line690="        let h12 = Math.idiv(h, 60);//[0,6]" line691="        let h22 = Math.idiv((h - h12 * 60) * 256, 60);//[0,255]" line692="        let temp = Math.abs((((h12 % 2) &lt;&lt; 8) + h22) - 256);" line693="        let x = (e * (256 - (temp))) &gt;&gt; 8;//[0,255], second largest component of this color" line694="        let r$: number;" line695="        let g$: number;" line696="        let b$: number;" line697="        if (h12 == 0) {" line698="            r$ = e; g$ = x; b$ = 0;" line699="        } else if (h12 == 1) {" line700="            r$ = x; g$ = e; b$ = 0;" line701="        } else if (h12 == 2) {" line702="            r$ = 0; g$ = e; b$ = x;" line703="        } else if (h12 == 3) {" line704="            r$ = 0; g$ = x; b$ = e;" line705="        } else if (h12 == 4) {" line706="            r$ = x; g$ = 0; b$ = e;" line707="        } else if (h12 == 5) {" line708="            r$ = e; g$ = 0; b$ = x;" line709="        }" line710="        let p = Math.idiv((Math.idiv((l * 2 &lt;&lt; 8), 100) - e), 2);" line711="        let w = r$ + p;" line712="        let q = g$ + p;" line713="        let a = b$ + p;" line714="" line715="        return (w &lt;&lt; 16) + (q &lt;&lt; 8) + a;" line716="    }" line717="}" numlines="718"></mutation></block></statement></block></xml>