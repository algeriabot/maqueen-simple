<xml xmlns="https://developers.google.com/blockly/xml"><block type="pxt-on-start" id="SU,M2qxF`j.uukCqw5?+" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="UHP+I@,*r1|2czqeeJ$I" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace maqueenSimple {" line1="" line2="    // weight=110 color=#8c24e0 icon=&quot;\uf085&quot; block=&quot;Robot&quot;" line3="" line4="    //Motor selection enumeration" line5="    export enum Motor {" line6="        //% block=&quot;left motor&quot;" line7="        LeftMotor," line8="        //% block=&quot;right motor&quot;" line9="        RightMotor," line10="        //% block=&quot;both motors&quot;" line11="        AllMotor," line12="    };" line13="" line14="    //Motor direction enumeration selection" line15="    export enum Dir {" line16="        //% block=&quot;forwards&quot;" line17="        Forward," line18="        //% block=&quot;backwards&quot;" line19="        Backward," line20="    };" line21="" line22="    //LED light selection enumeration" line23="    export enum MyEnumLed {" line24="        //% block=&quot;left LED light&quot;" line25="        LeftLed," line26="        //% block=&quot;right LED light&quot;" line27="        RightLed," line28="        //% block=&quot;all LED light&quot;" line29="        AllLed," line30="    };" line31="" line32="    //LED light switch enumeration selection" line33="    export enum MyEnumSwitch {" line34="        //% block=&quot;off&quot;" line35="        Close," line36="        //% block=&quot;on&quot;" line37="        Open," line38="    };" line39="" line40="    //Line sensor selection" line41="    export enum MyEnumLineSensor {" line42="        //% block=&quot;L1&quot;" line43="        SensorL1," line44="        //% block=&quot;M&quot;" line45="        SensorM," line46="        //% block=&quot;R1&quot;" line47="        SensorR1," line48="        //% block=&quot;L2&quot;" line49="        SensorL2," line50="        //% block=&quot;R2&quot;" line51="        SensorR2," line52="    };" line53="    /**" line54="     * Well known colors for a NeoPixel strip" line55="     */" line56="    export enum NeoPixelColors {" line57="        //% block=red" line58="        Red = 0xFF0000," line59="        //% block=orange" line60="        Orange = 0xFF6C00," line61="        //% block=yellow" line62="        Yellow = 0xFFFF00," line63="        //% block=green" line64="        Green = 0x00FF00," line65="        //% block=blue" line66="        Blue = 0x0000FF," line67="        //% block=indigo" line68="        Indigo = 0x4b0082," line69="        //% block=violet" line70="        Violet = 0x8a2be2," line71="        //% block=purple" line72="        Purple = 0xFF00FF," line73="        //% block=white" line74="        White = 0xFFFFFF," line75="        //% block=black" line76="        Black = 0x000000" line77="    }" line78="" line79="    export enum LeftRight {" line80="        //% block=&quot;↺ left&quot;" line81="        Left," line82="        //% block=&quot;↻ right&quot;" line83="        Right" line84="    }" line85="" line86="    export enum NeoPixelEnum {" line87="        //% block=&quot;all&quot;" line88="        All," line89="        //% block=&quot;front left&quot;" line90="        FrontLeft," line91="        //% block=&quot;front right&quot;" line92="        FrontRight," line93="        //% block=&quot;back left&quot;" line94="        BackLeft," line95="        //% block=&quot;back right&quot;" line96="        BackRight" line97="    }" line98="" line99="    const I2CADDR = 0x10;" line100="    const ADC0_REGISTER = 0X1E;" line101="    const ADC1_REGISTER = 0X20;" line102="    const ADC2_REGISTER = 0X22;" line103="    const ADC3_REGISTER = 0X24;" line104="    const ADC4_REGISTER = 0X26;" line105="    const LEFT_LED_REGISTER = 0X0B;" line106="    const RIGHT_LED_REGISTER = 0X0C;" line107="    const LEFT_MOTOR_REGISTER = 0X00;" line108="    const RIGHT_MOTOR_REGISTER = 0X02;" line109="    const LINE_STATE_REGISTER = 0X1D;" line110="    const VERSION_CNT_REGISTER = 0X32;" line111="    const VERSION_DATA_REGISTER = 0X33;" line112="" line113="    let irstate: number;" line114="    let neopixel_buf = pins.createBuffer(16 * 3);" line115="    for (let i = 0; i &lt; 16 * 3; i++) {" line116="        neopixel_buf[i] = 0" line117="    }" line118="    let _brightness = 255" line119="    let state: number;" line120="" line121="    /**" line122="     *  Init I2C until success" line123="     */" line124="" line125="    //% weight=0" line126="    //%block=&quot;initialize robot&quot;" line127="    export function I2CInit(): void {" line128="        let Version_v = 0;" line129="        pins.i2cWriteNumber(I2CADDR, 0x32, NumberFormat.Int8LE);" line130="        Version_v = pins.i2cReadNumber(I2CADDR, NumberFormat.Int8LE);" line131="        while (Version_v == 0) {" line132="            basic.showLeds(`" line133="                # . . . #" line134="                . # . # ." line135="                . . # . ." line136="                . # . # ." line137="                # . . . #" line138="                `, 10)" line139="            basic.pause(500)" line140="            basic.clearScreen()" line141="            pins.i2cWriteNumber(0x10, 0x32, NumberFormat.Int8LE);" line142="            Version_v = pins.i2cReadNumber(I2CADDR, NumberFormat.Int8LE);" line143="        }" line144="        basic.showLeds(`" line145="                . . . . ." line146="                . . . . #" line147="                . . . # ." line148="                # . # . ." line149="                . # . . ." line150="                `, 10)" line151="        basic.pause(500)" line152="        basic.clearScreen()" line153="    }" line154="" line155="    /**" line156="     * Move forward for a certain amount of time." line157="     * @param edir Direction to move in" line158="     * @param time How long to move forward for" line159="     */" line160="" line161="    //% block=&quot;move %edir for %time seconds&quot;" line162="    //% time.min=0 time.max=100" line163="    //% weight=100" line164="    export function moveForward(edir: Dir, time: number): void {" line165="        controlMotor(Motor.AllMotor, edir, 100);" line166="        basic.pause(time * 1000);" line167="        controlMotorStop(Motor.AllMotor);" line168="    }" line169="" line170="" line171="    /**" line172="     * Turn in a direction for a certain amount of time." line173="     * @param dir Direction to move in" line174="     * @param time How long to turn for" line175="     */" line176="    //% block=&quot;turn %dir for %time seconds&quot;" line177="    //% time.min=0 time.max=10" line178="    //% weight=99" line179="    export function turn(dir: LeftRight, time: number): void {" line180="        if (dir == LeftRight.Left) {" line181="            controlMotor(Motor.LeftMotor, Dir.Backward, 100);" line182="            controlMotor(Motor.RightMotor, Dir.Forward, 100);" line183="        } else if (dir == LeftRight.Right) {" line184="            controlMotor(Motor.RightMotor, Dir.Backward, 100);" line185="            controlMotor(Motor.LeftMotor, Dir.Forward, 100);" line186="        }" line187="        basic.pause(time * 1000);" line188="        controlMotorStop(Motor.AllMotor);" line189="    }" line190="" line191="    // /**" line192="    //  * Stop all motors." line193="    //  */" line194="    // //% block=&quot;stop&quot;" line195="    // export function stop(): void {" line196="    //     let allBuffer2 = pins.createBuffer(5);" line197="    //     allBuffer2[0] = LEFT_MOTOR_REGISTER;" line198="    //     allBuffer2[1] = 0;" line199="    //     allBuffer2[2] = 0;" line200="    //     allBuffer2[3] = 0;" line201="    //     allBuffer2[4] = 0;" line202="    //     pins.i2cWriteBuffer(I2CADDR, allBuffer2);" line203="    // }" line204="" line205="    /**" line206="     * Set motor to a speed" line207="     * @param emotor Motor selection " line208="     * @param edir   Motor direction" line209="     * @param speed  Motor speed control (0-255)" line210="     */" line211="" line212="    //% block=&quot;set %emotor moving %edir speed %speed&quot;" line213="    //% speed.min=0 speed.max=255" line214="    //% weight=98" line215="    export function controlMotor(emotor: Motor, edir: Dir, speed: number): void {" line216="        switch (emotor) {" line217="            case Motor.LeftMotor:" line218="                let leftBuffer = pins.createBuffer(3);" line219="                leftBuffer[0] = LEFT_MOTOR_REGISTER;" line220="                leftBuffer[1] = edir;" line221="                leftBuffer[2] = speed;" line222="                pins.i2cWriteBuffer(I2CADDR, leftBuffer);" line223="                break;" line224="            case Motor.RightMotor:" line225="                let rightBuffer = pins.createBuffer(3);" line226="                rightBuffer[0] = RIGHT_MOTOR_REGISTER;" line227="                rightBuffer[1] = edir;" line228="                rightBuffer[2] = speed;" line229="                pins.i2cWriteBuffer(I2CADDR, rightBuffer);" line230="                break;" line231="            default:" line232="                let allBuffer = pins.createBuffer(5);" line233="                allBuffer[0] = LEFT_MOTOR_REGISTER;" line234="                allBuffer[1] = edir;" line235="                allBuffer[2] = speed;" line236="                allBuffer[3] = edir;" line237="                allBuffer[4] = speed;" line238="                pins.i2cWriteBuffer(I2CADDR, allBuffer)" line239="                break;" line240="        }" line241="    }" line242="" line243="    /**" line244="     * Set motor to a speed" line245="     * @param emotor Motor selection" line246="     * @param speed  Motor speed control (-255 to 255)" line247="     " line248="" line249="    //% block=&quot;set %emotor speed %speed&quot;" line250="    //% speed.min=-255 speed.max=255" line251="    //% weight=97" line252="    export function controlMotor2(emotor: Motor, speed: number): void {" line253="        if (speed &lt; 0) {" line254="            controlMotor(emotor, Dir.Backward, Math.abs(speed));" line255="        } else {" line256="            controlMotor(emotor, Dir.Forward, speed);" line257="        }" line258="    }" line259="    */" line260="" line261="    /**" line262="     * Control the motor module to stop running" line263="     * @param emotor Motor selection enumeration" line264="     */" line265="" line266="    //% block=&quot;stop %emotor&quot;" line267="    //% weight=96" line268="    export function controlMotorStop(emotor: Motor): void {" line269="        switch (emotor) {" line270="            case Motor.LeftMotor:" line271="                let leftBuffer2 = pins.createBuffer(3);" line272="                leftBuffer2[0] = LEFT_MOTOR_REGISTER;" line273="                leftBuffer2[1] = 0;" line274="                leftBuffer2[2] = 0;" line275="                pins.i2cWriteBuffer(I2CADDR, leftBuffer2);" line276="                break;" line277="            case Motor.RightMotor:" line278="                let rightBuffer2 = pins.createBuffer(3);" line279="                rightBuffer2[0] = RIGHT_MOTOR_REGISTER;" line280="                rightBuffer2[1] = 0;" line281="                rightBuffer2[2] = 0;" line282="                pins.i2cWriteBuffer(I2CADDR, rightBuffer2);" line283="                break;" line284="            default:" line285="                let allBuffer22 = pins.createBuffer(5);" line286="                allBuffer22[0] = LEFT_MOTOR_REGISTER;" line287="                allBuffer22[1] = 0;" line288="                allBuffer22[2] = 0;" line289="                allBuffer22[3] = 0;" line290="                allBuffer22[4] = 0;" line291="                pins.i2cWriteBuffer(I2CADDR, allBuffer22)" line292="                break;" line293="        }" line294="    }" line295="" line296="    /**" line297="     * Control left and right LED light switch module" line298="     * @param eled LED lamp selection" line299="     * @param eSwitch Control LED light on or off" line300="     */" line301="" line302="    //% block=&quot;turn %eled %eSwitch&quot;" line303="    //% weight=95" line304="    export function controlLED(eled: MyEnumLed, eSwitch: MyEnumSwitch): void {" line305="        switch (eled) {" line306="            case MyEnumLed.LeftLed:" line307="                let leftLedControlBuffer = pins.createBuffer(2);" line308="                leftLedControlBuffer[0] = LEFT_LED_REGISTER;" line309="                leftLedControlBuffer[1] = eSwitch;" line310="                pins.i2cWriteBuffer(I2CADDR, leftLedControlBuffer);" line311="                break;" line312="            case MyEnumLed.RightLed:" line313="                let rightLedControlBuffer = pins.createBuffer(2);" line314="                rightLedControlBuffer[0] = RIGHT_LED_REGISTER;" line315="                rightLedControlBuffer[1] = eSwitch;" line316="                pins.i2cWriteBuffer(I2CADDR, rightLedControlBuffer);" line317="                break;" line318="            default:" line319="                let allLedControlBuffer = pins.createBuffer(3);" line320="                allLedControlBuffer[0] = LEFT_LED_REGISTER;" line321="                allLedControlBuffer[1] = eSwitch;" line322="                allLedControlBuffer[2] = eSwitch;" line323="                pins.i2cWriteBuffer(I2CADDR, allLedControlBuffer);" line324="                break;" line325="        }" line326="    }" line327="" line328="" line329="    /** " line330="    * Set the three primary color:red, green, and blue" line331="    * @param r  , eg: 100" line332="    * @param g  , eg: 100" line333="    * @param b  , eg: 100" line334="    " line335="" line336="    //*" line337="    //% weight=60" line338="    //% r.min=0 r.max=255" line339="    //% g.min=0 g.max=255" line340="    //% b.min=0 b.max=255" line341="    //% block=&quot;red|%r green|%g blue|%b&quot;" line342="    export function rgb(r: number, g: number, b: number): number {" line343="        return (r &lt;&lt; 16) + (g &lt;&lt; 8) + (b);" line344="    }" line345="    */" line346="" line347="    // /**" line348="    //  * The LED positions where you wish to begin and end" line349="    //  * @param from  , eg: 1" line350="    //  * @param to  , eg: 4" line351="    //  */" line352="" line353="    // //% weight=60" line354="    // //% from.min=0 from.max=3" line355="    // //% to.min=1 to.max=4" line356="    // //% block=&quot;range from |%from with|%to leds&quot;" line357="    // export function ledRange(from: number, to: number): number {" line358="    //     return ((from) &lt;&lt; 16) + (2 &lt;&lt; 8) + (to);" line359="    // }" line360="" line361="    /**" line362="     * Set the color of the specified LEDs" line363="     * @param index  , eg: 1" line364="     */" line365="" line366="    //% weight=94" line367="    //% index.min=0 index.max=3" line368="    //% block=&quot;show color |%rgb on |%light RGB light&quot;" line369="    export function setIndexColor(rgb: NeoPixelColors, light: NeoPixelEnum) {" line370="        let index = 0;" line371="        if (light == NeoPixelEnum.All) {" line372="            showColor(rgb);" line373="            return;" line374="        } else {" line375="            switch (light) {" line376="                case NeoPixelEnum.FrontLeft: index = 0; break;" line377="                case NeoPixelEnum.BackLeft: index = 1; break;" line378="                case NeoPixelEnum.BackRight: index = 2; break;" line379="                case NeoPixelEnum.FrontRight: index = 3; break;" line380="            }" line381="        }" line382="" line383="        let f = index;" line384="        let t = index;" line385="        let r = (rgb &gt;&gt; 16) * (_brightness / 255);" line386="        let g = ((rgb &gt;&gt; 8) &amp; 0xFF) * (_brightness / 255);" line387="        let b = ((rgb) &amp; 0xFF) * (_brightness / 255);" line388="" line389="        if (index &gt; 15) {" line390="            if (((index &gt;&gt; 8) &amp; 0xFF) == 0x02) {" line391="                f = index &gt;&gt; 16;" line392="                t = index &amp; 0xff;" line393="            } else {" line394="                f = 0;" line395="                t = -1;" line396="            }" line397="        }" line398="        for (let j = f; j &lt;= t; j++) {" line399="            neopixel_buf[j * 3 + 0] = Math.round(g)" line400="            neopixel_buf[j * 3 + 1] = Math.round(r)" line401="            neopixel_buf[j * 3 + 2] = Math.round(b)" line402="        }" line403="        ws2812b.sendBuffer(neopixel_buf, DigitalPin.P15)" line404="" line405="    }" line406="" line407="    /**" line408="     * Set the color of all RGB LEDs" line409="     */" line410="" line411="    export function showColor(rgb: NeoPixelColors) {" line412="        let s = (rgb &gt;&gt; 16) * (_brightness / 255);" line413="        let h = ((rgb &gt;&gt; 8) &amp; 0xFF) * (_brightness / 255);" line414="        let c = ((rgb) &amp; 0xFF) * (_brightness / 255);" line415="        for (let k = 0; k &lt; 16 * 3; k++) {" line416="            if ((k % 3) == 0)" line417="                neopixel_buf[k] = Math.round(h)" line418="            if ((k % 3) == 1)" line419="                neopixel_buf[k] = Math.round(s)" line420="            if ((k % 3) == 2)" line421="                neopixel_buf[k] = Math.round(c)" line422="        }" line423="        ws2812b.sendBuffer(neopixel_buf, DigitalPin.P15)" line424="    }" line425="" line426="    /**" line427="     * Set the brightness of RGB LED" line428="     * @param brightness  , eg: 100" line429="     */" line430="" line431="    //% weight=93" line432="    //% brightness.min=0 brightness.max=255" line433="    //% block=&quot;set RGB brightness to |%brightness&quot;" line434="    export function setBrightness(brightness: number) {" line435="        _brightness = brightness;" line436="    }" line437="" line438="    /**" line439="     * Turn off all RGB LEDs" line440="     */" line441="" line442="    //% weight=92" line443="    //% block=&quot;clear all RGB&quot;" line444="    export function ledBlank() {" line445="        showColor(0)" line446="    }" line447="" line448="    /**" line449="  * Acquiring ultrasonic data better" line450="  */" line451="" line452="    //% block=&quot;read ultrasonic distance (cm)&quot;" line453="    //% weight=91" line454="    export function readDistance(): number {" line455="        let trig = DigitalPin.P13;" line456="        let echo = DigitalPin.P14;" line457="        let data3;" line458="        pins.digitalWritePin(trig, 1);" line459="        basic.pause(1);" line460="        pins.digitalWritePin(trig, 0)" line461="        if (pins.digitalReadPin(echo) == 0) {" line462="            pins.digitalWritePin(trig, 0);" line463="            pins.digitalWritePin(trig, 1);" line464="            basic.pause(20);" line465="            pins.digitalWritePin(trig, 0);" line466="            data3 = pins.pulseIn(echo, PulseValue.High, 500 * 58);" line467="        } else {" line468="            pins.digitalWritePin(trig, 1);" line469="            pins.digitalWritePin(trig, 0);" line470="            basic.pause(20);" line471="            pins.digitalWritePin(trig, 0);" line472="            data3 = pins.pulseIn(echo, PulseValue.High, 500 * 58)" line473="        }" line474="        data3 = data3 / 59;" line475="        if (data3 &lt;= 0)" line476="            return 0;" line477="        if (data3 &gt; 500)" line478="            return 500;" line479="        return Math.round(data3);" line480="    }" line481="" line482="    /**" line483="    * Get the state of the patrol sensor" line484="    * @param eline Select the inspection sensor enumeration" line485="    */" line486="" line487="    //% block=&quot;read line sensor %eline state&quot;" line488="    //% weight=90" line489="    export function readLineSensorState(eline: MyEnumLineSensor): number {" line490="        pins.i2cWriteNumber(I2CADDR, LINE_STATE_REGISTER, NumberFormat.Int8LE);" line491="        let data = pins.i2cReadNumber(I2CADDR, NumberFormat.Int8LE)" line492="        let state2;" line493="        switch (eline) {" line494="            case MyEnumLineSensor.SensorL1:" line495="                state2 = (data &amp; 0x08) == 0x08 ? 1 : 0;" line496="                break;" line497="            case MyEnumLineSensor.SensorM:" line498="                state2 = (data &amp; 0x04) == 0x04 ? 1 : 0;" line499="                break;" line500="            case MyEnumLineSensor.SensorR1:" line501="                state2 = (data &amp; 0x02) == 0x02 ? 1 : 0;" line502="                break;" line503="            case MyEnumLineSensor.SensorL2:" line504="                state2 = (data &amp; 0x10) == 0X10 ? 1 : 0;" line505="                break;" line506="            default:" line507="                state2 = (data &amp; 0x01) == 0x01 ? 1 : 0;" line508="                break;" line509="        }" line510="        return state2;" line511="    }" line512="" line513="    // /**" line514="    //  * RGB LEDs display rainbow colors " line515="    //  */" line516="" line517="    // //% weight=50" line518="    // //% startHue.defl=1" line519="    // //% endHue.defl=360" line520="    // //% startHue.min=0 startHue.max=360" line521="    // //% endHue.min=0 endHue.max=360" line522="    // export function ledRainbow(startHue: number, endHue: number) {" line523="    //     startHue = startHue &gt;&gt; 0;" line524="    //     endHue = endHue &gt;&gt; 0;" line525="    //     const saturation = 100;" line526="    //     const luminance = 50;" line527="    //     let steps = 3 + 1;" line528="    //     const direction = HueInterpolationDirection.Clockwise;" line529="" line530="    //     //hue" line531="    //     const h1 = startHue;" line532="    //     const h2 = endHue;" line533="    //     const hDistCW = ((h2 + 360) - h1) % 360;" line534="    //     const hStepCW = Math.idiv((hDistCW * 100), steps);" line535="    //     const hDistCCW = ((h1 + 360) - h2) % 360;" line536="    //     const hStepCCW = Math.idiv(-(hDistCCW * 100), steps);" line537="    //     let hStep: number;" line538="    //     if (direction === HueInterpolationDirection.Clockwise) {" line539="    //         hStep = hStepCW;" line540="    //     } else if (direction === HueInterpolationDirection.CounterClockwise) {" line541="    //         hStep = hStepCCW;" line542="    //     } else {" line543="    //         hStep = hDistCW &lt; hDistCCW ? hStepCW : hStepCCW;" line544="    //     }" line545="    //     const h1_100 = h1 * 100; //we multiply by 100 so we keep more accurate results while doing interpolation" line546="" line547="    //     //sat" line548="    //     const s1 = saturation;" line549="    //     const s2 = saturation;" line550="    //     const sDist = s2 - s1;" line551="    //     const sStep = Math.idiv(sDist, steps);" line552="    //     const s1_100 = s1 * 100;" line553="" line554="    //     //lum" line555="    //     const l1 = luminance;" line556="    //     const l2 = luminance;" line557="    //     const lDist = l2 - l1;" line558="    //     const lStep = Math.idiv(lDist, steps);" line559="    //     const l1_100 = l1 * 100" line560="" line561="    //     //interpolate" line562="    //     if (steps === 1) {" line563="    //         writeBuff(0, hsl(h1 + hStep, s1 + sStep, l1 + lStep))" line564="    //     } else {" line565="    //         writeBuff(0, hsl(startHue, saturation, luminance));" line566="    //         for (let l = 1; l &lt; steps - 1; l++) {" line567="    //             const m = Math.idiv((h1_100 + l * hStep), 100) + 360;" line568="    //             const u = Math.idiv((s1_100 + l * sStep), 100);" line569="    //             const n = Math.idiv((l1_100 + l * lStep), 100);" line570="    //             writeBuff(0 + l, hsl(m, u, n));" line571="    //         }" line572="    //         writeBuff(3, hsl(endHue, saturation, luminance));" line573="    //     }" line574="    //     ws2812b.sendBuffer(neopixel_buf, DigitalPin.P15)" line575="    // }" line576="" line577="    export enum HueInterpolationDirection {" line578="        Clockwise," line579="        CounterClockwise," line580="        Shortest" line581="    }" line582="" line583="    function writeBuff(index: number, rgb: number) {" line584="        let v = (rgb &gt;&gt; 16) * (_brightness / 255);" line585="        let o = ((rgb &gt;&gt; 8) &amp; 0xFF) * (_brightness / 255);" line586="        let d = ((rgb) &amp; 0xFF) * (_brightness / 255);" line587="        neopixel_buf[index * 3 + 0] = Math.round(o)" line588="        neopixel_buf[index * 3 + 1] = Math.round(v)" line589="        neopixel_buf[index * 3 + 2] = Math.round(d)" line590="    }" line591="" line592="    function hsl(h: number, s: number, l: number): number {" line593="        h = Math.round(h);" line594="        s = Math.round(s);" line595="        l = Math.round(l);" line596="" line597="        h = h % 360;" line598="        s = Math.clamp(0, 99, s);" line599="        l = Math.clamp(0, 99, l);" line600="        let e = Math.idiv((((100 - Math.abs(2 * l - 100)) * s) &lt;&lt; 8), 10000); //chroma, [0,255]" line601="        let h12 = Math.idiv(h, 60);//[0,6]" line602="        let h22 = Math.idiv((h - h12 * 60) * 256, 60);//[0,255]" line603="        let temp = Math.abs((((h12 % 2) &lt;&lt; 8) + h22) - 256);" line604="        let x = (e * (256 - (temp))) &gt;&gt; 8;//[0,255], second largest component of this color" line605="        let r$: number;" line606="        let g$: number;" line607="        let b$: number;" line608="        if (h12 == 0) {" line609="            r$ = e; g$ = x; b$ = 0;" line610="        } else if (h12 == 1) {" line611="            r$ = x; g$ = e; b$ = 0;" line612="        } else if (h12 == 2) {" line613="            r$ = 0; g$ = e; b$ = x;" line614="        } else if (h12 == 3) {" line615="            r$ = 0; g$ = x; b$ = e;" line616="        } else if (h12 == 4) {" line617="            r$ = x; g$ = 0; b$ = e;" line618="        } else if (h12 == 5) {" line619="            r$ = e; g$ = 0; b$ = x;" line620="        }" line621="        let p = Math.idiv((Math.idiv((l * 2 &lt;&lt; 8), 100) - e), 2);" line622="        let w = r$ + p;" line623="        let q = g$ + p;" line624="        let a = b$ + p;" line625="" line626="        return (w &lt;&lt; 16) + (q &lt;&lt; 8) + a;" line627="    }" line628="}" numlines="629"></mutation></block></statement></block></xml>