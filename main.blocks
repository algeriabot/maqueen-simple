<xml xmlns="https://developers.google.com/blockly/xml"><block type="pxt-on-start" id="H=]erMWIUe~_FWdSnLEJ" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="]JZ??fVIS=ZT*U.;K2|:" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace maqueenSimple {" line1="" line2="    //Motor selection enumeration" line3="    export enum MyEnumMotor {" line4="        //% block=&quot;left motor&quot;" line5="        LeftMotor," line6="        //% block=&quot;right motor&quot;" line7="        RightMotor," line8="        //% block=&quot;both motors&quot;" line9="        AllMotor," line10="    };" line11="" line12="    //Motor direction enumeration selection" line13="    export enum MyEnumDir {" line14="        //% block=&quot;forward&quot;" line15="        Forward," line16="        //% block=&quot;backward&quot;" line17="        Backward," line18="    };" line19="" line20="    //LED light selection enumeration" line21="    export enum MyEnumLed {" line22="        //% block=&quot;left LED light&quot;" line23="        LeftLed," line24="        //% block=&quot;right LED light&quot;" line25="        RightLed," line26="        //% block=&quot;all LED light&quot;" line27="        AllLed," line28="    };" line29="" line30="    //LED light switch enumeration selection" line31="    export enum MyEnumSwitch {" line32="        //% block=&quot;off&quot;" line33="        Close," line34="        //% block=&quot;on&quot;" line35="        Open," line36="    };" line37="" line38="    //Line sensor selection" line39="    export enum MyEnumLineSensor {" line40="        //% block=&quot;L1&quot;" line41="        SensorL1," line42="        //% block=&quot;M&quot;" line43="        SensorM," line44="        //% block=&quot;R1&quot;" line45="        SensorR1," line46="        //% block=&quot;L2&quot;" line47="        SensorL2," line48="        //% block=&quot;R2&quot;" line49="        SensorR2," line50="    };" line51="    /**" line52="     * Well known colors for a NeoPixel strip" line53="     */" line54="    export enum NeoPixelColors {" line55="        //% block=red" line56="        Red = 0xFF0000," line57="        //% block=orange" line58="        Orange = 0xFFA500," line59="        //% block=yellow" line60="        Yellow = 0xFFFF00," line61="        //% block=green" line62="        Green = 0x00FF00," line63="        //% block=blue" line64="        Blue = 0x0000FF," line65="        //% block=indigo" line66="        Indigo = 0x4b0082," line67="        //% block=violet" line68="        Violet = 0x8a2be2," line69="        //% block=purple" line70="        Purple = 0xFF00FF," line71="        //% block=white" line72="        White = 0xFFFFFF," line73="        //% block=black" line74="        Black = 0x000000" line75="    }" line76="" line77="    const I2CADDR = 0x10;" line78="    const ADC0_REGISTER = 0X1E;" line79="    const ADC1_REGISTER = 0X20;" line80="    const ADC2_REGISTER = 0X22;" line81="    const ADC3_REGISTER = 0X24;" line82="    const ADC4_REGISTER = 0X26;" line83="    const LEFT_LED_REGISTER = 0X0B;" line84="    const RIGHT_LED_REGISTER = 0X0C;" line85="    const LEFT_MOTOR_REGISTER = 0X00;" line86="    const RIGHT_MOTOR_REGISTER = 0X02;" line87="    const LINE_STATE_REGISTER = 0X1D;" line88="    const VERSION_CNT_REGISTER = 0X32;" line89="    const VERSION_DATA_REGISTER = 0X33;" line90="" line91="    let irstate: number;" line92="    let neopixel_buf = pins.createBuffer(16 * 3);" line93="    for (let i = 0; i &lt; 16 * 3; i++) {" line94="        neopixel_buf[i] = 0" line95="    }" line96="    let _brightness = 255" line97="    let state: number;" line98="" line99="    /**" line100="     *  Init I2C until success" line101="     */" line102="" line103="    //% weight=100" line104="    //%block=&quot;initialize robot&quot;" line105="    export function I2CInit(): void {" line106="        let Version_v = 0;" line107="        pins.i2cWriteNumber(I2CADDR, 0x32, NumberFormat.Int8LE);" line108="        Version_v = pins.i2cReadNumber(I2CADDR, NumberFormat.Int8LE);" line109="        while (Version_v == 0) {" line110="            basic.showLeds(`" line111="                # . . . #" line112="                . # . # ." line113="                . . # . ." line114="                . # . # ." line115="                # . . . #" line116="                `, 10)" line117="            basic.pause(500)" line118="            basic.clearScreen()" line119="            pins.i2cWriteNumber(0x10, 0x32, NumberFormat.Int8LE);" line120="            Version_v = pins.i2cReadNumber(I2CADDR, NumberFormat.Int8LE);" line121="        }" line122="        basic.showLeds(`" line123="                . . . . ." line124="                . . . . #" line125="                . . . # ." line126="                # . # . ." line127="                . # . . ." line128="                `, 10)" line129="        basic.pause(500)" line130="        basic.clearScreen()" line131="    }" line132="" line133="    /**" line134="     * Move forward for a certain amount of time." line135="     * @param edir Direction to move in" line136="     * @param seconds How long to move forward for" line137="     */" line138="" line139="    //% block=&quot;move %edir for %seconds seconds&quot;" line140="    //% seconds.min=0 seconds.max=100" line141="    //% weight=99" line142="    export function moveForward(edir: MyEnumDir, seconds: number): void {" line143="        controlMotor(MyEnumMotor.AllMotor, edir, 100);" line144="        basic.pause(seconds * 1000);" line145="        controlMotorStop(MyEnumMotor.AllMotor);" line146="    }" line147="" line148="    /**" line149="     * Stop all motors." line150="     */" line151="    //% block=&quot;stop&quot;" line152="    export function stop(): void {" line153="        let allBuffer2 = pins.createBuffer(5);" line154="        allBuffer2[0] = LEFT_MOTOR_REGISTER;" line155="        allBuffer2[1] = 0;" line156="        allBuffer2[2] = 0;" line157="        allBuffer2[3] = 0;" line158="        allBuffer2[4] = 0;" line159="        pins.i2cWriteBuffer(I2CADDR, allBuffer2);" line160="    }" line161="" line162="    /**" line163="     * Control motor module running" line164="     * @param emotor Motor selection enumeration" line165="     * @param edir   Motor direction selection enumeration" line166="     * @param speed  Motor speed control, eg:100" line167="     */" line168="" line169="    //% block=&quot;set %emotor direction %edir speed %speed&quot;" line170="    //% speed.min=0 speed.max=255" line171="    //% weight=99" line172="    export function controlMotor(emotor: MyEnumMotor, edir: MyEnumDir, speed: number): void {" line173="        switch (emotor) {" line174="            case MyEnumMotor.LeftMotor:" line175="                let leftBuffer = pins.createBuffer(3);" line176="                leftBuffer[0] = LEFT_MOTOR_REGISTER;" line177="                leftBuffer[1] = edir;" line178="                leftBuffer[2] = speed;" line179="                pins.i2cWriteBuffer(I2CADDR, leftBuffer);" line180="                break;" line181="            case MyEnumMotor.RightMotor:" line182="                let rightBuffer = pins.createBuffer(3);" line183="                rightBuffer[0] = RIGHT_MOTOR_REGISTER;" line184="                rightBuffer[1] = edir;" line185="                rightBuffer[2] = speed;" line186="                pins.i2cWriteBuffer(I2CADDR, rightBuffer);" line187="                break;" line188="            default:" line189="                let allBuffer = pins.createBuffer(5);" line190="                allBuffer[0] = LEFT_MOTOR_REGISTER;" line191="                allBuffer[1] = edir;" line192="                allBuffer[2] = speed;" line193="                allBuffer[3] = edir;" line194="                allBuffer[4] = speed;" line195="                pins.i2cWriteBuffer(I2CADDR, allBuffer)" line196="                break;" line197="        }" line198="    }" line199="" line200="    /**" line201="     * Control the motor module to stop running" line202="     * @param emotor Motor selection enumeration" line203="     */" line204="" line205="    //% block=&quot;set %emotor stop&quot;" line206="    //% weight=98" line207="    export function controlMotorStop(emotor: MyEnumMotor): void {" line208="        switch (emotor) {" line209="            case MyEnumMotor.LeftMotor:" line210="                let leftBuffer2 = pins.createBuffer(3);" line211="                leftBuffer2[0] = LEFT_MOTOR_REGISTER;" line212="                leftBuffer2[1] = 0;" line213="                leftBuffer2[2] = 0;" line214="                pins.i2cWriteBuffer(I2CADDR, leftBuffer2);" line215="                break;" line216="            case MyEnumMotor.RightMotor:" line217="                let rightBuffer2 = pins.createBuffer(3);" line218="                rightBuffer2[0] = RIGHT_MOTOR_REGISTER;" line219="                rightBuffer2[1] = 0;" line220="                rightBuffer2[2] = 0;" line221="                pins.i2cWriteBuffer(I2CADDR, rightBuffer2);" line222="                break;" line223="            default:" line224="                let allBuffer22 = pins.createBuffer(5);" line225="                allBuffer22[0] = LEFT_MOTOR_REGISTER;" line226="                allBuffer22[1] = 0;" line227="                allBuffer22[2] = 0;" line228="                allBuffer22[3] = 0;" line229="                allBuffer22[4] = 0;" line230="                pins.i2cWriteBuffer(I2CADDR, allBuffer22)" line231="                break;" line232="        }" line233="    }" line234="" line235="    /**" line236="     * Control left and right LED light switch module" line237="     * @param eled LED lamp selection" line238="     * @param eSwitch Control LED light on or off" line239="     */" line240="" line241="    //% block=&quot;turn %eled %eSwitch&quot;" line242="    //% weight=97" line243="    export function controlLED(eled: MyEnumLed, eSwitch: MyEnumSwitch): void {" line244="        switch (eled) {" line245="            case MyEnumLed.LeftLed:" line246="                let leftLedControlBuffer = pins.createBuffer(2);" line247="                leftLedControlBuffer[0] = LEFT_LED_REGISTER;" line248="                leftLedControlBuffer[1] = eSwitch;" line249="                pins.i2cWriteBuffer(I2CADDR, leftLedControlBuffer);" line250="                break;" line251="            case MyEnumLed.RightLed:" line252="                let rightLedControlBuffer = pins.createBuffer(2);" line253="                rightLedControlBuffer[0] = RIGHT_LED_REGISTER;" line254="                rightLedControlBuffer[1] = eSwitch;" line255="                pins.i2cWriteBuffer(I2CADDR, rightLedControlBuffer);" line256="                break;" line257="            default:" line258="                let allLedControlBuffer = pins.createBuffer(3);" line259="                allLedControlBuffer[0] = LEFT_LED_REGISTER;" line260="                allLedControlBuffer[1] = eSwitch;" line261="                allLedControlBuffer[2] = eSwitch;" line262="                pins.i2cWriteBuffer(I2CADDR, allLedControlBuffer);" line263="                break;" line264="        }" line265="    }" line266="" line267="    /**" line268="     * Get the state of the patrol sensor" line269="     * @param eline Select the inspection sensor enumeration" line270="     */" line271="" line272="    //% block=&quot;read line sensor %eline state&quot;" line273="    //% weight=96" line274="    export function readLineSensorState(eline: MyEnumLineSensor): number {" line275="        pins.i2cWriteNumber(I2CADDR, LINE_STATE_REGISTER, NumberFormat.Int8LE);" line276="        let data = pins.i2cReadNumber(I2CADDR, NumberFormat.Int8LE)" line277="        let state2;" line278="        switch (eline) {" line279="            case MyEnumLineSensor.SensorL1:" line280="                state2 = (data &amp; 0x08) == 0x08 ? 1 : 0;" line281="                break;" line282="            case MyEnumLineSensor.SensorM:" line283="                state2 = (data &amp; 0x04) == 0x04 ? 1 : 0;" line284="                break;" line285="            case MyEnumLineSensor.SensorR1:" line286="                state2 = (data &amp; 0x02) == 0x02 ? 1 : 0;" line287="                break;" line288="            case MyEnumLineSensor.SensorL2:" line289="                state2 = (data &amp; 0x10) == 0X10 ? 1 : 0;" line290="                break;" line291="            default:" line292="                state2 = (data &amp; 0x01) == 0x01 ? 1 : 0;" line293="                break;" line294="        }" line295="        return state2;" line296="    }" line297="" line298="    /**" line299="     * The ADC data of the patrol sensor is obtained" line300="     * @param eline Select the inspection sensor enumeration" line301="     */" line302="" line303="    //% block=&quot;read line sensor %eline  ADC data&quot;" line304="    //% weight=95" line305="    export function readLineSensorData(eline: MyEnumLineSensor): number {" line306="        let data2;" line307="        switch (eline) {" line308="            case MyEnumLineSensor.SensorR2:" line309="                pins.i2cWriteNumber(I2CADDR, ADC0_REGISTER, NumberFormat.Int8LE);" line310="                let adc0Buffer = pins.i2cReadBuffer(I2CADDR, 1);" line311="                data2 = adc0Buffer[1] &lt;&lt; 8 | adc0Buffer[0]" line312="                break;" line313="            case MyEnumLineSensor.SensorR1:" line314="                pins.i2cWriteNumber(I2CADDR, ADC1_REGISTER, NumberFormat.Int8LE);" line315="                let adc1Buffer = pins.i2cReadBuffer(I2CADDR, 2);" line316="                data2 = adc1Buffer[1] &lt;&lt; 8 | adc1Buffer[0];" line317="                break;" line318="            case MyEnumLineSensor.SensorM:" line319="                pins.i2cWriteNumber(I2CADDR, ADC2_REGISTER, NumberFormat.Int8LE);" line320="                let adc2Buffer = pins.i2cReadBuffer(I2CADDR, 2);" line321="                data2 = adc2Buffer[1] &lt;&lt; 8 | adc2Buffer[0];" line322="                break;" line323="            case MyEnumLineSensor.SensorL1:" line324="                pins.i2cWriteNumber(I2CADDR, ADC3_REGISTER, NumberFormat.Int8LE);" line325="                let adc3Buffer = pins.i2cReadBuffer(I2CADDR, 2);" line326="                data2 = adc3Buffer[1] &lt;&lt; 1 | adc3Buffer[0];" line327="                break;" line328="            default:" line329="                pins.i2cWriteNumber(I2CADDR, ADC4_REGISTER, NumberFormat.Int8LE);" line330="                let adc4Buffer = pins.i2cReadBuffer(I2CADDR, 2);" line331="                data2 = adc4Buffer[1] &lt;&lt; 8 | adc4Buffer[0];" line332="                break;" line333="" line334="        }" line335="        return data2;" line336="    }" line337="" line338="    /**" line339="     * Acquiring ultrasonic data better" line340="     */" line341="" line342="    //% block=&quot;read ultrasonic distance (cm)&quot;" line343="    //% weight=94" line344="    export function readDistance(): number {" line345="        let trig=DigitalPin.P13;" line346="        let echo=DigitalPin.P14;" line347="        let data3;" line348="        pins.digitalWritePin(trig, 1);" line349="        basic.pause(1);" line350="        pins.digitalWritePin(trig, 0)" line351="        if (pins.digitalReadPin(echo) == 0) {" line352="            pins.digitalWritePin(trig, 0);" line353="            pins.digitalWritePin(trig, 1);" line354="            basic.pause(20);" line355="            pins.digitalWritePin(trig, 0);" line356="            data3 = pins.pulseIn(echo, PulseValue.High, 500 * 58);" line357="        } else {" line358="            pins.digitalWritePin(trig, 1);" line359="            pins.digitalWritePin(trig, 0);" line360="            basic.pause(20);" line361="            pins.digitalWritePin(trig, 0);" line362="            data3 = pins.pulseIn(echo, PulseValue.High, 500 * 58)" line363="        }" line364="        data3 = data3 / 59;" line365="        if (data3 &lt;= 0)" line366="            return 0;" line367="        if (data3 &gt; 500)" line368="            return 500;" line369="        return Math.round(data3);" line370="    }" line371="" line372="    /**" line373="     * Acquiring ultrasonic data" line374="     * @param trig trig pin selection enumeration, eg:DigitalPin.P13" line375="     * @param echo echo pin selection enumeration, eg:DigitalPin.P14" line376="     */" line377="" line378="    //% block=&quot;set ultrasonic sensor TRIG pin %trig ECHO pin %echo read data unit:cm&quot;" line379="    //% weight=94" line380="    export function readUltrasonic(trig: DigitalPin, echo: DigitalPin): number {" line381="        let data32;" line382="        pins.digitalWritePin(trig, 1);" line383="        basic.pause(1);" line384="        pins.digitalWritePin(trig, 0)" line385="        if (pins.digitalReadPin(echo) == 0) {" line386="            pins.digitalWritePin(trig, 0);" line387="            pins.digitalWritePin(trig, 1);" line388="            basic.pause(20);" line389="            pins.digitalWritePin(trig, 0);" line390="            data32 = pins.pulseIn(echo, PulseValue.High, 500 * 58);" line391="        } else {" line392="            pins.digitalWritePin(trig, 1);" line393="            pins.digitalWritePin(trig, 0);" line394="            basic.pause(20);" line395="            pins.digitalWritePin(trig, 0);" line396="            data32 = pins.pulseIn(echo, PulseValue.High, 500 * 58)" line397="        }" line398="        data32 = data32 / 59;" line399="        if (data32 &lt;= 0)" line400="            return 0;" line401="        if (data32 &gt; 500)" line402="            return 500;" line403="        return Math.round(data32);" line404="    }" line405="" line406="    /**" line407="     * Getting the version number" line408="     */" line409="" line410="    //% block=&quot;read version&quot;" line411="    //% weight=2" line412="    //% advanced=true" line413="    export function readVersion(): string {" line414="        let version;" line415="        pins.i2cWriteNumber(I2CADDR, VERSION_CNT_REGISTER, NumberFormat.Int8LE);" line416="        version = pins.i2cReadNumber(I2CADDR, NumberFormat.Int8LE);" line417="        pins.i2cWriteNumber(I2CADDR, VERSION_DATA_REGISTER, NumberFormat.Int8LE);" line418="        version = pins.i2cReadBuffer(I2CADDR, version);" line419="        let versionString = version.toString();" line420="        return versionString" line421="    }" line422="" line423="" line424="" line425="    /** " line426="    * Set the three primary color:red, green, and blue" line427="    * @param r  , eg: 100" line428="    * @param g  , eg: 100" line429="    * @param b  , eg: 100" line430="    */" line431="" line432="    //% weight=60" line433="    //% r.min=0 r.max=255" line434="    //% g.min=0 g.max=255" line435="    //% b.min=0 b.max=255" line436="    //% block=&quot;red|%r green|%g blue|%b&quot;" line437="    export function rgb(r: number, g: number, b: number): number {" line438="        return (r &lt;&lt; 16) + (g &lt;&lt; 8) + (b);" line439="    }" line440="" line441="    /**" line442="     * The LED positions where you wish to begin and end" line443="     * @param from  , eg: 1" line444="     * @param to  , eg: 4" line445="     */" line446="" line447="    //% weight=60" line448="    //% from.min=0 from.max=3" line449="    //% to.min=1 to.max=4" line450="    //% block=&quot;range from |%from with|%to leds&quot;" line451="    export function ledRange(from: number, to: number): number {" line452="        return ((from) &lt;&lt; 16) + (2 &lt;&lt; 8) + (to);" line453="    }" line454="" line455="    /**" line456="     * Set the color of the specified LEDs" line457="     * @param index  , eg: 1" line458="     */" line459="" line460="    //% weight=60" line461="    //% index.min=0 index.max=3" line462="    //% block=&quot;RGB light |%index show color|%rgb&quot;" line463="    export function setIndexColor(index: number, rgb: NeoPixelColors) {" line464="        let f = index;" line465="        let t = index;" line466="        let r = (rgb &gt;&gt; 16) * (_brightness / 255);" line467="        let g = ((rgb &gt;&gt; 8) &amp; 0xFF) * (_brightness / 255);" line468="        let b = ((rgb) &amp; 0xFF) * (_brightness / 255);" line469="" line470="        if (index &gt; 15) {" line471="            if (((index &gt;&gt; 8) &amp; 0xFF) == 0x02) {" line472="                f = index &gt;&gt; 16;" line473="                t = index &amp; 0xff;" line474="            } else {" line475="                f = 0;" line476="                t = -1;" line477="            }" line478="        }" line479="        for (let j = f; j &lt;= t; j++) {" line480="            neopixel_buf[j * 3 + 0] = Math.round(g)" line481="            neopixel_buf[j * 3 + 1] = Math.round(r)" line482="            neopixel_buf[j * 3 + 2] = Math.round(b)" line483="        }" line484="        ws2812b.sendBuffer(neopixel_buf, DigitalPin.P15)" line485="" line486="    }" line487="" line488="    /**" line489="     * Set the color of all RGB LEDs" line490="     */" line491="" line492="    //% weight=60" line493="    //% block=&quot; RGB show color |%rgb&quot;" line494="    export function showColor(rgb: NeoPixelColors) {" line495="        let s = (rgb &gt;&gt; 16) * (_brightness / 255);" line496="        let h = ((rgb &gt;&gt; 8) &amp; 0xFF) * (_brightness / 255);" line497="        let c = ((rgb) &amp; 0xFF) * (_brightness / 255);" line498="        for (let k = 0; k &lt; 16 * 3; k++) {" line499="            if ((k % 3) == 0)" line500="                neopixel_buf[k] = Math.round(h)" line501="            if ((k % 3) == 1)" line502="                neopixel_buf[k] = Math.round(s)" line503="            if ((k % 3) == 2)" line504="                neopixel_buf[k] = Math.round(c)" line505="        }" line506="        ws2812b.sendBuffer(neopixel_buf, DigitalPin.P15)" line507="    }" line508="" line509="    /**" line510="     * Set the brightness of RGB LED" line511="     * @param brightness  , eg: 100" line512="     */" line513="" line514="    //% weight=70" line515="    //% brightness.min=0 brightness.max=255" line516="    //% block=&quot;set RGB brightness to |%brightness&quot;" line517="    export function setBrightness(brightness: number) {" line518="        _brightness = brightness;" line519="    }" line520="" line521="    /**" line522="     * Turn off all RGB LEDs" line523="     */" line524="" line525="    //% weight=40" line526="    //% block=&quot;clear all RGB&quot;" line527="    export function ledBlank() {" line528="        showColor(0)" line529="    }" line530="" line531="    /**" line532="     * RGB LEDs display rainbow colors " line533="     */" line534="" line535="    //% weight=50" line536="    //% startHue.defl=1" line537="    //% endHue.defl=360" line538="    //% startHue.min=0 startHue.max=360" line539="    //% endHue.min=0 endHue.max=360" line540="    //% blockId=led_rainbow block=&quot;set RGB show rainbow color from|%startHue to|%endHue&quot;" line541="    export function ledRainbow(startHue: number, endHue: number) {" line542="        startHue = startHue &gt;&gt; 0;" line543="        endHue = endHue &gt;&gt; 0;" line544="        const saturation = 100;" line545="        const luminance = 50;" line546="        let steps = 3 + 1;" line547="        const direction = HueInterpolationDirection.Clockwise;" line548="" line549="        //hue" line550="        const h1 = startHue;" line551="        const h2 = endHue;" line552="        const hDistCW = ((h2 + 360) - h1) % 360;" line553="        const hStepCW = Math.idiv((hDistCW * 100), steps);" line554="        const hDistCCW = ((h1 + 360) - h2) % 360;" line555="        const hStepCCW = Math.idiv(-(hDistCCW * 100), steps);" line556="        let hStep: number;" line557="        if (direction === HueInterpolationDirection.Clockwise) {" line558="            hStep = hStepCW;" line559="        } else if (direction === HueInterpolationDirection.CounterClockwise) {" line560="            hStep = hStepCCW;" line561="        } else {" line562="            hStep = hDistCW &lt; hDistCCW ? hStepCW : hStepCCW;" line563="        }" line564="        const h1_100 = h1 * 100; //we multiply by 100 so we keep more accurate results while doing interpolation" line565="" line566="        //sat" line567="        const s1 = saturation;" line568="        const s2 = saturation;" line569="        const sDist = s2 - s1;" line570="        const sStep = Math.idiv(sDist, steps);" line571="        const s1_100 = s1 * 100;" line572="" line573="        //lum" line574="        const l1 = luminance;" line575="        const l2 = luminance;" line576="        const lDist = l2 - l1;" line577="        const lStep = Math.idiv(lDist, steps);" line578="        const l1_100 = l1 * 100" line579="" line580="        //interpolate" line581="        if (steps === 1) {" line582="            writeBuff(0, hsl(h1 + hStep, s1 + sStep, l1 + lStep))" line583="        } else {" line584="            writeBuff(0, hsl(startHue, saturation, luminance));" line585="            for (let l = 1; l &lt; steps - 1; l++) {" line586="                const m = Math.idiv((h1_100 + l * hStep), 100) + 360;" line587="                const u = Math.idiv((s1_100 + l * sStep), 100);" line588="                const n = Math.idiv((l1_100 + l * lStep), 100);" line589="                writeBuff(0 + l, hsl(m, u, n));" line590="            }" line591="            writeBuff(3, hsl(endHue, saturation, luminance));" line592="        }" line593="        ws2812b.sendBuffer(neopixel_buf, DigitalPin.P15)" line594="    }" line595="" line596="    export enum HueInterpolationDirection {" line597="        Clockwise," line598="        CounterClockwise," line599="        Shortest" line600="    }" line601="" line602="    function writeBuff(index: number, rgb: number) {" line603="        let v = (rgb &gt;&gt; 16) * (_brightness / 255);" line604="        let o = ((rgb &gt;&gt; 8) &amp; 0xFF) * (_brightness / 255);" line605="        let d = ((rgb) &amp; 0xFF) * (_brightness / 255);" line606="        neopixel_buf[index * 3 + 0] = Math.round(o)" line607="        neopixel_buf[index * 3 + 1] = Math.round(v)" line608="        neopixel_buf[index * 3 + 2] = Math.round(d)" line609="    }" line610="" line611="    function hsl(h: number, s: number, l: number): number {" line612="        h = Math.round(h);" line613="        s = Math.round(s);" line614="        l = Math.round(l);" line615="" line616="        h = h % 360;" line617="        s = Math.clamp(0, 99, s);" line618="        l = Math.clamp(0, 99, l);" line619="        let e = Math.idiv((((100 - Math.abs(2 * l - 100)) * s) &lt;&lt; 8), 10000); //chroma, [0,255]" line620="        let h12 = Math.idiv(h, 60);//[0,6]" line621="        let h22 = Math.idiv((h - h12 * 60) * 256, 60);//[0,255]" line622="        let temp = Math.abs((((h12 % 2) &lt;&lt; 8) + h22) - 256);" line623="        let x = (e * (256 - (temp))) &gt;&gt; 8;//[0,255], second largest component of this color" line624="        let r$: number;" line625="        let g$: number;" line626="        let b$: number;" line627="        if (h12 == 0) {" line628="            r$ = e; g$ = x; b$ = 0;" line629="        } else if (h12 == 1) {" line630="            r$ = x; g$ = e; b$ = 0;" line631="        } else if (h12 == 2) {" line632="            r$ = 0; g$ = e; b$ = x;" line633="        } else if (h12 == 3) {" line634="            r$ = 0; g$ = x; b$ = e;" line635="        } else if (h12 == 4) {" line636="            r$ = x; g$ = 0; b$ = e;" line637="        } else if (h12 == 5) {" line638="            r$ = e; g$ = 0; b$ = x;" line639="        }" line640="        let p = Math.idiv((Math.idiv((l * 2 &lt;&lt; 8), 100) - e), 2);" line641="        let w = r$ + p;" line642="        let q = g$ + p;" line643="        let a = b$ + p;" line644="" line645="        return (w &lt;&lt; 16) + (q &lt;&lt; 8) + a;" line646="    }" line647="}" numlines="648"></mutation></block></statement></block></xml>