<xml xmlns="https://developers.google.com/blockly/xml"><block type="pxt-on-start" id="6QBDzlr);2g.Q3W,2lMP" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="kX_o5;gCbG}Ms~1k%@}5" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace maqueenSimple {" line1="" line2="    //Motor selection enumeration" line3="    export enum MyEnumMotor {" line4="        //% block=&quot;left motor&quot;" line5="        LeftMotor," line6="        //% block=&quot;right motor&quot;" line7="        RightMotor," line8="        //% block=&quot;all motor&quot;" line9="        AllMotor," line10="    };" line11="" line12="    //Motor direction enumeration selection" line13="    export enum MyEnumDir {" line14="        //% block=&quot;rotate forward&quot;" line15="        Forward," line16="        //% block=&quot;backward&quot;" line17="        Backward," line18="    };" line19="" line20="    //LED light selection enumeration" line21="    export enum MyEnumLed {" line22="        //% block=&quot;left LED light&quot;" line23="        LeftLed," line24="        //% block=&quot;right LED light&quot;" line25="        RightLed," line26="        //% block=&quot;all LED light&quot;" line27="        AllLed," line28="    };" line29="" line30="    //LED light switch enumeration selection" line31="    export enum MyEnumSwitch {" line32="        //% block=&quot;on&quot;" line33="        Close," line34="        //% block=&quot;off&quot;" line35="        Open," line36="    };" line37="" line38="    //Line sensor selection" line39="    export enum MyEnumLineSensor {" line40="        //% block=&quot;L1&quot;" line41="        SensorL1," line42="        //% block=&quot;M&quot;" line43="        SensorM," line44="        //% block=&quot;R1&quot;" line45="        SensorR1," line46="        //% block=&quot;L2&quot;" line47="        SensorL2," line48="        //% block=&quot;R2&quot;" line49="        SensorR2," line50="    };" line51="    /**" line52="     * Well known colors for a NeoPixel strip" line53="     */" line54="    export enum NeoPixelColors {" line55="        //% block=red" line56="        Red = 0xFF0000," line57="        //% block=orange" line58="        Orange = 0xFFA500," line59="        //% block=yellow" line60="        Yellow = 0xFFFF00," line61="        //% block=green" line62="        Green = 0x00FF00," line63="        //% block=blue" line64="        Blue = 0x0000FF," line65="        //% block=indigo" line66="        Indigo = 0x4b0082," line67="        //% block=violet" line68="        Violet = 0x8a2be2," line69="        //% block=purple" line70="        Purple = 0xFF00FF," line71="        //% block=white" line72="        White = 0xFFFFFF," line73="        //% block=black" line74="        Black = 0x000000" line75="    }" line76="" line77="    const I2CADDR = 0x10;" line78="    const ADC0_REGISTER = 0X1E;" line79="    const ADC1_REGISTER = 0X20;" line80="    const ADC2_REGISTER = 0X22;" line81="    const ADC3_REGISTER = 0X24;" line82="    const ADC4_REGISTER = 0X26;" line83="    const LEFT_LED_REGISTER = 0X0B;" line84="    const RIGHT_LED_REGISTER = 0X0C;" line85="    const LEFT_MOTOR_REGISTER = 0X00;" line86="    const RIGHT_MOTOR_REGISTER = 0X02;" line87="    const LINE_STATE_REGISTER = 0X1D;" line88="    const VERSION_CNT_REGISTER = 0X32;" line89="    const VERSION_DATA_REGISTER = 0X33;" line90="" line91="    let irstate: number;" line92="    let neopixel_buf = pins.createBuffer(16 * 3);" line93="    for (let i = 0; i &lt; 16 * 3; i++) {" line94="        neopixel_buf[i] = 0" line95="    }" line96="    let _brightness = 255" line97="    let state: number;" line98="" line99="    /**" line100="     *  Init I2C until success" line101="     */" line102="" line103="    //% weight=100" line104="    //%block=&quot;initialize robot&quot;" line105="    export function I2CInit(): void {" line106="        let Version_v = 0;" line107="        pins.i2cWriteNumber(I2CADDR, 0x32, NumberFormat.Int8LE);" line108="        Version_v = pins.i2cReadNumber(I2CADDR, NumberFormat.Int8LE);" line109="        while (Version_v == 0) {" line110="            basic.showLeds(`" line111="                # . . . #" line112="                . # . # ." line113="                . . # . ." line114="                . # . # ." line115="                # . . . #" line116="                `, 10)" line117="            basic.pause(500)" line118="            basic.clearScreen()" line119="            pins.i2cWriteNumber(0x10, 0x32, NumberFormat.Int8LE);" line120="            Version_v = pins.i2cReadNumber(I2CADDR, NumberFormat.Int8LE);" line121="        }" line122="        basic.showLeds(`" line123="                . . . . ." line124="                . . . . #" line125="                . . . # ." line126="                # . # . ." line127="                . # . . ." line128="                `, 10)" line129="        basic.pause(500)" line130="        basic.clearScreen()" line131="    }" line132="" line133="    /**" line134="     * Move forward for a certain amount of time." line135="     * @param seconds How long to move forward for" line136="     */" line137="" line138="    //% block=&quot;move forward for %eseconds seconds&quot;" line139="    //% seconds.min=0 seconds.max=100" line140="    //% weight=99" line141="    export function moveForward(seconds: number): void {" line142="        controlMotor(MyEnumMotor.AllMotor, MyEnumDir.Forward, 100);" line143="        basic.pause(seconds * 1000);" line144="        controlMotorStop(MyEnumMotor.AllMotor);" line145="    }" line146="" line147="    /**" line148="     * Control motor module running" line149="     * @param emotor Motor selection enumeration" line150="     * @param edir   Motor direction selection enumeration" line151="     * @param speed  Motor speed control, eg:100" line152="     */" line153="" line154="    //% block=&quot;set %emotor direction %edir speed %speed&quot;" line155="    //% speed.min=0 speed.max=255" line156="    //% weight=99" line157="    export function controlMotor(emotor: MyEnumMotor, edir: MyEnumDir, speed: number): void {" line158="        switch (emotor) {" line159="            case MyEnumMotor.LeftMotor:" line160="                let leftBuffer = pins.createBuffer(3);" line161="                leftBuffer[0] = LEFT_MOTOR_REGISTER;" line162="                leftBuffer[1] = edir;" line163="                leftBuffer[2] = speed;" line164="                pins.i2cWriteBuffer(I2CADDR, leftBuffer);" line165="                break;" line166="            case MyEnumMotor.RightMotor:" line167="                let rightBuffer = pins.createBuffer(3);" line168="                rightBuffer[0] = RIGHT_MOTOR_REGISTER;" line169="                rightBuffer[1] = edir;" line170="                rightBuffer[2] = speed;" line171="                pins.i2cWriteBuffer(I2CADDR, rightBuffer);" line172="                break;" line173="            default:" line174="                let allBuffer = pins.createBuffer(5);" line175="                allBuffer[0] = LEFT_MOTOR_REGISTER;" line176="                allBuffer[1] = edir;" line177="                allBuffer[2] = speed;" line178="                allBuffer[3] = edir;" line179="                allBuffer[4] = speed;" line180="                pins.i2cWriteBuffer(I2CADDR, allBuffer)" line181="                break;" line182="        }" line183="    }" line184="" line185="    /**" line186="     * Control the motor module to stop running" line187="     * @param emotor Motor selection enumeration" line188="     */" line189="" line190="    //% block=&quot;set %emotor stop&quot;" line191="    //% weight=98" line192="    export function controlMotorStop(emotor: MyEnumMotor): void {" line193="        switch (emotor) {" line194="            case MyEnumMotor.LeftMotor:" line195="                let leftBuffer2 = pins.createBuffer(3);" line196="                leftBuffer2[0] = LEFT_MOTOR_REGISTER;" line197="                leftBuffer2[1] = 0;" line198="                leftBuffer2[2] = 0;" line199="                pins.i2cWriteBuffer(I2CADDR, leftBuffer2);" line200="                break;" line201="            case MyEnumMotor.RightMotor:" line202="                let rightBuffer2 = pins.createBuffer(3);" line203="                rightBuffer2[0] = RIGHT_MOTOR_REGISTER;" line204="                rightBuffer2[1] = 0;" line205="                rightBuffer2[2] = 0;" line206="                pins.i2cWriteBuffer(I2CADDR, rightBuffer2);" line207="                break;" line208="            default:" line209="                let allBuffer2 = pins.createBuffer(5);" line210="                allBuffer2[0] = LEFT_MOTOR_REGISTER;" line211="                allBuffer2[1] = 0;" line212="                allBuffer2[2] = 0;" line213="                allBuffer2[3] = 0;" line214="                allBuffer2[4] = 0;" line215="                pins.i2cWriteBuffer(I2CADDR, allBuffer2)" line216="                break;" line217="        }" line218="    }" line219="" line220="    /**" line221="     * Control left and right LED light switch module" line222="     * @param eled LED lamp selection" line223="     * @param eSwitch Control LED light on or off" line224="     */" line225="" line226="    //% block=&quot;control %eled %eSwitch&quot;" line227="    //% weight=97" line228="    export function controlLED(eled: MyEnumLed, eSwitch: MyEnumSwitch): void {" line229="        switch (eled) {" line230="            case MyEnumLed.LeftLed:" line231="                let leftLedControlBuffer = pins.createBuffer(2);" line232="                leftLedControlBuffer[0] = LEFT_LED_REGISTER;" line233="                leftLedControlBuffer[1] = eSwitch;" line234="                pins.i2cWriteBuffer(I2CADDR, leftLedControlBuffer);" line235="                break;" line236="            case MyEnumLed.RightLed:" line237="                let rightLedControlBuffer = pins.createBuffer(2);" line238="                rightLedControlBuffer[0] = RIGHT_LED_REGISTER;" line239="                rightLedControlBuffer[1] = eSwitch;" line240="                pins.i2cWriteBuffer(I2CADDR, rightLedControlBuffer);" line241="                break;" line242="            default:" line243="                let allLedControlBuffer = pins.createBuffer(3);" line244="                allLedControlBuffer[0] = LEFT_LED_REGISTER;" line245="                allLedControlBuffer[1] = eSwitch;" line246="                allLedControlBuffer[2] = eSwitch;" line247="                pins.i2cWriteBuffer(I2CADDR, allLedControlBuffer);" line248="                break;" line249="        }" line250="    }" line251="" line252="    /**" line253="     * Get the state of the patrol sensor" line254="     * @param eline Select the inspection sensor enumeration" line255="     */" line256="" line257="    //% block=&quot;read line sensor %eline state&quot;" line258="    //% weight=96" line259="    export function readLineSensorState(eline: MyEnumLineSensor): number {" line260="        pins.i2cWriteNumber(I2CADDR, LINE_STATE_REGISTER, NumberFormat.Int8LE);" line261="        let data = pins.i2cReadNumber(I2CADDR, NumberFormat.Int8LE)" line262="        let state2;" line263="        switch (eline) {" line264="            case MyEnumLineSensor.SensorL1:" line265="                state2 = (data &amp; 0x08) == 0x08 ? 1 : 0;" line266="                break;" line267="            case MyEnumLineSensor.SensorM:" line268="                state2 = (data &amp; 0x04) == 0x04 ? 1 : 0;" line269="                break;" line270="            case MyEnumLineSensor.SensorR1:" line271="                state2 = (data &amp; 0x02) == 0x02 ? 1 : 0;" line272="                break;" line273="            case MyEnumLineSensor.SensorL2:" line274="                state2 = (data &amp; 0x10) == 0X10 ? 1 : 0;" line275="                break;" line276="            default:" line277="                state2 = (data &amp; 0x01) == 0x01 ? 1 : 0;" line278="                break;" line279="        }" line280="        return state2;" line281="    }" line282="" line283="    /**" line284="     * The ADC data of the patrol sensor is obtained" line285="     * @param eline Select the inspection sensor enumeration" line286="     */" line287="" line288="    //% block=&quot;read line sensor %eline  ADC data&quot;" line289="    //% weight=95" line290="    export function readLineSensorData(eline: MyEnumLineSensor): number {" line291="        let data2;" line292="        switch (eline) {" line293="            case MyEnumLineSensor.SensorR2:" line294="                pins.i2cWriteNumber(I2CADDR, ADC0_REGISTER, NumberFormat.Int8LE);" line295="                let adc0Buffer = pins.i2cReadBuffer(I2CADDR, 1);" line296="                data2 = adc0Buffer[1] &lt;&lt; 8 | adc0Buffer[0]" line297="                break;" line298="            case MyEnumLineSensor.SensorR1:" line299="                pins.i2cWriteNumber(I2CADDR, ADC1_REGISTER, NumberFormat.Int8LE);" line300="                let adc1Buffer = pins.i2cReadBuffer(I2CADDR, 2);" line301="                data2 = adc1Buffer[1] &lt;&lt; 8 | adc1Buffer[0];" line302="                break;" line303="            case MyEnumLineSensor.SensorM:" line304="                pins.i2cWriteNumber(I2CADDR, ADC2_REGISTER, NumberFormat.Int8LE);" line305="                let adc2Buffer = pins.i2cReadBuffer(I2CADDR, 2);" line306="                data2 = adc2Buffer[1] &lt;&lt; 8 | adc2Buffer[0];" line307="                break;" line308="            case MyEnumLineSensor.SensorL1:" line309="                pins.i2cWriteNumber(I2CADDR, ADC3_REGISTER, NumberFormat.Int8LE);" line310="                let adc3Buffer = pins.i2cReadBuffer(I2CADDR, 2);" line311="                data2 = adc3Buffer[1] &lt;&lt; 1 | adc3Buffer[0];" line312="                break;" line313="            default:" line314="                pins.i2cWriteNumber(I2CADDR, ADC4_REGISTER, NumberFormat.Int8LE);" line315="                let adc4Buffer = pins.i2cReadBuffer(I2CADDR, 2);" line316="                data2 = adc4Buffer[1] &lt;&lt; 8 | adc4Buffer[0];" line317="                break;" line318="" line319="        }" line320="        return data2;" line321="    }" line322="" line323="    /**" line324="     * Acquiring ultrasonic data" line325="     * @param trig trig pin selection enumeration, eg:DigitalPin.P13" line326="     * @param echo echo pin selection enumeration, eg:DigitalPin.P14" line327="     */" line328="" line329="    //% block=&quot;set ultrasonic sensor TRIG pin %trig ECHO pin %echo read data unit:cm&quot;" line330="    //% weight=94" line331="    export function readUltrasonic(trig: DigitalPin, echo: DigitalPin): number {" line332="        let data3;" line333="        pins.digitalWritePin(trig, 1);" line334="        basic.pause(1);" line335="        pins.digitalWritePin(trig, 0)" line336="        if (pins.digitalReadPin(echo) == 0) {" line337="            pins.digitalWritePin(trig, 0);" line338="            pins.digitalWritePin(trig, 1);" line339="            basic.pause(20);" line340="            pins.digitalWritePin(trig, 0);" line341="            data3 = pins.pulseIn(echo, PulseValue.High, 500 * 58);" line342="        } else {" line343="            pins.digitalWritePin(trig, 1);" line344="            pins.digitalWritePin(trig, 0);" line345="            basic.pause(20);" line346="            pins.digitalWritePin(trig, 0);" line347="            data3 = pins.pulseIn(echo, PulseValue.High, 500 * 58)" line348="        }" line349="        data3 = data3 / 59;" line350="        if (data3 &lt;= 0)" line351="            return 0;" line352="        if (data3 &gt; 500)" line353="            return 500;" line354="        return Math.round(data3);" line355="    }" line356="" line357="    /**" line358="     * Getting the version number" line359="     */" line360="" line361="    //% block=&quot;read version&quot;" line362="    //% weight=2" line363="    //% advanced=true" line364="    export function readVersion(): string {" line365="        let version;" line366="        pins.i2cWriteNumber(I2CADDR, VERSION_CNT_REGISTER, NumberFormat.Int8LE);" line367="        version = pins.i2cReadNumber(I2CADDR, NumberFormat.Int8LE);" line368="        pins.i2cWriteNumber(I2CADDR, VERSION_DATA_REGISTER, NumberFormat.Int8LE);" line369="        version = pins.i2cReadBuffer(I2CADDR, version);" line370="        let versionString = version.toString();" line371="        return versionString" line372="    }" line373="" line374="" line375="" line376="    /** " line377="    * Set the three primary color:red, green, and blue" line378="    * @param r  , eg: 100" line379="    * @param g  , eg: 100" line380="    * @param b  , eg: 100" line381="    */" line382="" line383="    //% weight=60" line384="    //% r.min=0 r.max=255" line385="    //% g.min=0 g.max=255" line386="    //% b.min=0 b.max=255" line387="    //% block=&quot;red|%r green|%g blue|%b&quot;" line388="    export function rgb(r: number, g: number, b: number): number {" line389="        return (r &lt;&lt; 16) + (g &lt;&lt; 8) + (b);" line390="    }" line391="" line392="    /**" line393="     * The LED positions where you wish to begin and end" line394="     * @param from  , eg: 1" line395="     * @param to  , eg: 4" line396="     */" line397="" line398="    //% weight=60" line399="    //% from.min=0 from.max=3" line400="    //% to.min=1 to.max=4" line401="    //% block=&quot;range from |%from with|%to leds&quot;" line402="    export function ledRange(from: number, to: number): number {" line403="        return ((from) &lt;&lt; 16) + (2 &lt;&lt; 8) + (to);" line404="    }" line405="" line406="    /**" line407="     * Set the color of the specified LEDs" line408="     * @param index  , eg: 1" line409="     */" line410="" line411="    //% weight=60" line412="    //% index.min=0 index.max=3" line413="    //% block=&quot;RGB light |%index show color|%rgb&quot;" line414="    export function setIndexColor(index: number, rgb: NeoPixelColors) {" line415="        let f = index;" line416="        let t = index;" line417="        let r = (rgb &gt;&gt; 16) * (_brightness / 255);" line418="        let g = ((rgb &gt;&gt; 8) &amp; 0xFF) * (_brightness / 255);" line419="        let b = ((rgb) &amp; 0xFF) * (_brightness / 255);" line420="" line421="        if (index &gt; 15) {" line422="            if (((index &gt;&gt; 8) &amp; 0xFF) == 0x02) {" line423="                f = index &gt;&gt; 16;" line424="                t = index &amp; 0xff;" line425="            } else {" line426="                f = 0;" line427="                t = -1;" line428="            }" line429="        }" line430="        for (let j = f; j &lt;= t; j++) {" line431="            neopixel_buf[j * 3 + 0] = Math.round(g)" line432="            neopixel_buf[j * 3 + 1] = Math.round(r)" line433="            neopixel_buf[j * 3 + 2] = Math.round(b)" line434="        }" line435="        ws2812b.sendBuffer(neopixel_buf, DigitalPin.P15)" line436="" line437="    }" line438="" line439="    /**" line440="     * Set the color of all RGB LEDs" line441="     */" line442="" line443="    //% weight=60" line444="    //% block=&quot; RGB show color |%rgb&quot;" line445="    export function showColor(rgb: NeoPixelColors) {" line446="        let s = (rgb &gt;&gt; 16) * (_brightness / 255);" line447="        let h = ((rgb &gt;&gt; 8) &amp; 0xFF) * (_brightness / 255);" line448="        let c = ((rgb) &amp; 0xFF) * (_brightness / 255);" line449="        for (let k = 0; k &lt; 16 * 3; k++) {" line450="            if ((k % 3) == 0)" line451="                neopixel_buf[k] = Math.round(h)" line452="            if ((k % 3) == 1)" line453="                neopixel_buf[k] = Math.round(s)" line454="            if ((k % 3) == 2)" line455="                neopixel_buf[k] = Math.round(c)" line456="        }" line457="        ws2812b.sendBuffer(neopixel_buf, DigitalPin.P15)" line458="    }" line459="" line460="    /**" line461="     * Set the brightness of RGB LED" line462="     * @param brightness  , eg: 100" line463="     */" line464="" line465="    //% weight=70" line466="    //% brightness.min=0 brightness.max=255" line467="    //% block=&quot;set RGB brightness to |%brightness&quot;" line468="    export function setBrightness(brightness: number) {" line469="        _brightness = brightness;" line470="    }" line471="" line472="    /**" line473="     * Turn off all RGB LEDs" line474="     */" line475="" line476="    //% weight=40" line477="    //% block=&quot;clear all RGB&quot;" line478="    export function ledBlank() {" line479="        showColor(0)" line480="    }" line481="" line482="    /**" line483="     * RGB LEDs display rainbow colors " line484="     */" line485="" line486="    //% weight=50" line487="    //% startHue.defl=1" line488="    //% endHue.defl=360" line489="    //% startHue.min=0 startHue.max=360" line490="    //% endHue.min=0 endHue.max=360" line491="    //% blockId=led_rainbow block=&quot;set RGB show rainbow color from|%startHue to|%endHue&quot;" line492="    export function ledRainbow(startHue: number, endHue: number) {" line493="        startHue = startHue &gt;&gt; 0;" line494="        endHue = endHue &gt;&gt; 0;" line495="        const saturation = 100;" line496="        const luminance = 50;" line497="        let steps = 3 + 1;" line498="        const direction = HueInterpolationDirection.Clockwise;" line499="" line500="        //hue" line501="        const h1 = startHue;" line502="        const h2 = endHue;" line503="        const hDistCW = ((h2 + 360) - h1) % 360;" line504="        const hStepCW = Math.idiv((hDistCW * 100), steps);" line505="        const hDistCCW = ((h1 + 360) - h2) % 360;" line506="        const hStepCCW = Math.idiv(-(hDistCCW * 100), steps);" line507="        let hStep: number;" line508="        if (direction === HueInterpolationDirection.Clockwise) {" line509="            hStep = hStepCW;" line510="        } else if (direction === HueInterpolationDirection.CounterClockwise) {" line511="            hStep = hStepCCW;" line512="        } else {" line513="            hStep = hDistCW &lt; hDistCCW ? hStepCW : hStepCCW;" line514="        }" line515="        const h1_100 = h1 * 100; //we multiply by 100 so we keep more accurate results while doing interpolation" line516="" line517="        //sat" line518="        const s1 = saturation;" line519="        const s2 = saturation;" line520="        const sDist = s2 - s1;" line521="        const sStep = Math.idiv(sDist, steps);" line522="        const s1_100 = s1 * 100;" line523="" line524="        //lum" line525="        const l1 = luminance;" line526="        const l2 = luminance;" line527="        const lDist = l2 - l1;" line528="        const lStep = Math.idiv(lDist, steps);" line529="        const l1_100 = l1 * 100" line530="" line531="        //interpolate" line532="        if (steps === 1) {" line533="            writeBuff(0, hsl(h1 + hStep, s1 + sStep, l1 + lStep))" line534="        } else {" line535="            writeBuff(0, hsl(startHue, saturation, luminance));" line536="            for (let l = 1; l &lt; steps - 1; l++) {" line537="                const m = Math.idiv((h1_100 + l * hStep), 100) + 360;" line538="                const u = Math.idiv((s1_100 + l * sStep), 100);" line539="                const n = Math.idiv((l1_100 + l * lStep), 100);" line540="                writeBuff(0 + l, hsl(m, u, n));" line541="            }" line542="            writeBuff(3, hsl(endHue, saturation, luminance));" line543="        }" line544="        ws2812b.sendBuffer(neopixel_buf, DigitalPin.P15)" line545="    }" line546="" line547="    export enum HueInterpolationDirection {" line548="        Clockwise," line549="        CounterClockwise," line550="        Shortest" line551="    }" line552="" line553="    function writeBuff(index: number, rgb: number) {" line554="        let v = (rgb &gt;&gt; 16) * (_brightness / 255);" line555="        let o = ((rgb &gt;&gt; 8) &amp; 0xFF) * (_brightness / 255);" line556="        let d = ((rgb) &amp; 0xFF) * (_brightness / 255);" line557="        neopixel_buf[index * 3 + 0] = Math.round(o)" line558="        neopixel_buf[index * 3 + 1] = Math.round(v)" line559="        neopixel_buf[index * 3 + 2] = Math.round(d)" line560="    }" line561="" line562="    function hsl(h: number, s: number, l: number): number {" line563="        h = Math.round(h);" line564="        s = Math.round(s);" line565="        l = Math.round(l);" line566="" line567="        h = h % 360;" line568="        s = Math.clamp(0, 99, s);" line569="        l = Math.clamp(0, 99, l);" line570="        let e = Math.idiv((((100 - Math.abs(2 * l - 100)) * s) &lt;&lt; 8), 10000); //chroma, [0,255]" line571="        let h12 = Math.idiv(h, 60);//[0,6]" line572="        let h22 = Math.idiv((h - h12 * 60) * 256, 60);//[0,255]" line573="        let temp = Math.abs((((h12 % 2) &lt;&lt; 8) + h22) - 256);" line574="        let x = (e * (256 - (temp))) &gt;&gt; 8;//[0,255], second largest component of this color" line575="        let r$: number;" line576="        let g$: number;" line577="        let b$: number;" line578="        if (h12 == 0) {" line579="            r$ = e; g$ = x; b$ = 0;" line580="        } else if (h12 == 1) {" line581="            r$ = x; g$ = e; b$ = 0;" line582="        } else if (h12 == 2) {" line583="            r$ = 0; g$ = e; b$ = x;" line584="        } else if (h12 == 3) {" line585="            r$ = 0; g$ = x; b$ = e;" line586="        } else if (h12 == 4) {" line587="            r$ = x; g$ = 0; b$ = e;" line588="        } else if (h12 == 5) {" line589="            r$ = e; g$ = 0; b$ = x;" line590="        }" line591="        let p = Math.idiv((Math.idiv((l * 2 &lt;&lt; 8), 100) - e), 2);" line592="        let w = r$ + p;" line593="        let q = g$ + p;" line594="        let a = b$ + p;" line595="" line596="        return (w &lt;&lt; 16) + (q &lt;&lt; 8) + a;" line597="    }" line598="}" numlines="599"></mutation></block></statement></block></xml>